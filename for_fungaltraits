
###############共起ネットワークについて##################################################################################################################################
library(dplyr)
library(igraph)
library(RColorBrewer)

ASV.fungi.table <- read.table("~/Desktop/sueyoshi/Analize＆Datas/data_YAKUSHIMA/results(DADA2~relative_abundance)/for_ITS/rarefied_ASV_table.txt",header = T)
ASV.bacteria.table <- read.table("~/Desktop/sueyoshi/Analize＆Datas/data_YAKUSHIMA/results(DADA2~relative_abundance)/for_16S/1207_primer除いたver/rarefied_ASV_table.txt", header = T)
ASV.amf.table <- read.table("~/Desktop/sueyoshi/Analize＆Datas/data_YAKUSHIMA/results(DADA2~relative_abundance)/for_AMF/うまく行ったデータ/rarefied_ASV_table_fixed_1108.txt", header = T)
fungaltraits.table <- read.table("~/Desktop/sueyoshi/Analize＆Datas/data_YAKUSHIMA/for_Fungaltrait/result/241119_withasv/241119_fungaltraits_results.txt", header = T)
picrust.table <- read.csv("~/Desktop/sueyoshi/Analize＆Datas/data_YAKUSHIMA/picrust2/for_heatmap/results_picrust2.csv", header = T, row.names = 1)

#taxonomy
taxonomy_fungi <- ASV.fungi.table [,(ncol(ASV.fungi.table)-6):ncol(ASV.fungi.table), drop = FALSE]
taxonomy_bacteria <- ASV.bacteria.table [,(ncol(ASV.bacteria.table)-5):ncol(ASV.bacteria.table), drop = FALSE]
taxonomy_amf <- ASV.amf.table[,(ncol(ASV.amf.table)-11):ncol(ASV.amf.table), drop = FALSE]
taxonomy_amf <- taxonomy_amf[,1:(ncol(taxonomy_amf)-5)]
fungaltraits <- fungaltraits.table[, (ncol(fungaltraits.table)-30):ncol(fungaltraits.table), drop = FALSE]

# Remove "k__", "p__" and "c__" before phylum name
taxonomy_fungi <- data.frame(lapply(taxonomy_fungi, function(x){gsub(pattern="k__", replacement = "", x)}),stringsAsFactors = FALSE)
taxonomy_fungi <- data.frame(lapply(taxonomy_fungi, function(x){gsub(pattern="p__", replacement = "", x)}),stringsAsFactors = FALSE)
taxonomy_fungi <- data.frame(lapply(taxonomy_fungi, function(x){gsub(pattern="c__", replacement = "", x)}),stringsAsFactors = FALSE)
taxonomy_fungi <- data.frame(lapply(taxonomy_fungi, function(x){gsub(pattern="o__", replacement = "", x)}),stringsAsFactors = FALSE)
taxonomy_fungi <- data.frame(lapply(taxonomy_fungi, function(x){gsub(pattern="f__", replacement = "", x)}),stringsAsFactors = FALSE)
taxonomy_fungi <- data.frame(lapply(taxonomy_fungi, function(x){gsub(pattern="g__", replacement = "", x)}),stringsAsFactors = FALSE)
taxonomy_fungi <- data.frame(lapply(taxonomy_fungi, function(x){gsub(pattern="s__", replacement = "", x)}),stringsAsFactors = FALSE)
rownames(taxonomy_fungi) <- rownames(ASV.fungi.table)  # 行名を元の行名で設定

#例: サンプル名と植栽区の対応を持つデータフレームを読み込む(tree & location)
sample_info <- read.csv("~/Desktop/sueyoshi/Analize＆Datas/data_YAKUSHIMA/network_analysis/scores/sample_info.csv", header = T, row.names = 1)

#ASV_table
ASV.fungi.table <- ASV.fungi.table[,1:(ncol(ASV.fungi.table)-7)]
ASV.bacteria.table <- ASV.bacteria.table[,1:(ncol(ASV.bacteria.table)-6)]
ASV.amf.table <- ASV.amf.table[,1:(ncol(ASV.amf.table)-12)]

#行と列を入れ替える
ASV.fungi.table <- t(ASV.fungi.table)
ASV.bacteria.table <- t(ASV.bacteria.table)
ASV.amf.table <- t(ASV.amf.table)

# ASV._.tableをデータフレームに変換
ASV.fungi.table <- as.data.frame(ASV.fungi.table)
ASV.bacteria.table <- as.data.frame(ASV.bacteria.table)
ASV.amf.table <- as.data.frame(ASV.amf.table)

#データセットを相対頻度に変換
asv_fungi_relative <- ASV.fungi.table %>%
  # 各サンプルの総リード数を計算
  mutate(total_reads = rowSums(across(everything()))) %>%
  # 各ASVのリード数をそのサンプルの総リード数で割る
  mutate(across(everything(), ~ . / total_reads)) %>%
  # 不要な合計リード数の列を削除
  select(-total_reads)

asv_bacteria_relative <- ASV.bacteria.table %>%
  # 各サンプルの総リード数を計算
  mutate(total_reads = rowSums(across(everything()))) %>%
  # 各ASVのリード数をそのサンプルの総リード数で割る
  mutate(across(everything(), ~ . / total_reads)) %>%
  # 不要な合計リード数の列を削除
  select(-total_reads)

picrust2_relative <- picrust.table %>%
  # 各サンプルの総リード数を計算
  mutate(total_reads = rowSums(across(everything()))) %>%
  # 各ASVのリード数をそのサンプルの総リード数で割る
  mutate(across(everything(), ~ . / total_reads)) %>%
  # 不要な合計リード数の列を削除
  select(-total_reads)

asv_amf_relative <- ASV.amf.table %>%
  # 各サンプルの総リード数を計算
  mutate(total_reads = rowSums(across(everything()))) %>%
  # 各ASVのリード数をそのサンプルの総リード数で割る
  mutate(across(everything(), ~ . / total_reads)) %>%
  # 不要な合計リード数の列を削除
  select(-total_reads)

# いずれかの行で0.01以上のASVを持つ列のみを残す
asv_fungi_filtered <- asv_fungi_relative %>%
  select(where(~ any(. > 0.01)))  
asv_bacteria_filtered <- asv_bacteria_relative %>%
  select(where(~ any(. > 0.01))) 
picrust2_filtered <- picrust2_relative %>%
  select(where(~ any(. > 0.01))) 
asv_amf_filtered <- asv_amf_relative %>%
  select(where(~ any(. > 0.01))) 

# asv_fungi_filteredの列名に基づいてtaxonomy_fungiから行名が一致する行を抽出
taxonomy_fungi_filtered <- taxonomy_fungi[rownames(taxonomy_fungi) %in% colnames(asv_fungi_filtered), ]
function_fungi_filtered <- fungaltraits[rownames(taxonomy_fungi) %in% colnames(asv_fungi_filtered), ]
taxonomy_bacteria_filtered <- taxonomy_bacteria[rownames(taxonomy_bacteria) %in% colnames(asv_bacteria_filtered), ]
taxonomy_amf_filtered <- taxonomy_amf[rownames(taxonomy_amf) %in% colnames(asv_amf_filtered), ]

# 列名にプレフィックスを追加
colnames(asv_fungi_filtered) <- paste("fungi", colnames(asv_fungi_filtered), sep = "_")
rownames(taxonomy_fungi_filtered) <- paste("fungi", rownames(taxonomy_fungi_filtered), sep = "_")
rownames(function_fungi_filtered) <- paste("fungi", rownames(taxonomy_fungi_filtered), sep = "_")
colnames(asv_bacteria_filtered) <- paste("bacteria", colnames(asv_bacteria_filtered), sep = "_")
rownames(taxonomy_bacteria_filtered) <- paste("bacteria", rownames(taxonomy_bacteria_filtered), sep = "_")
colnames(asv_amf_filtered) <- paste("amf", colnames(asv_amf_filtered), sep = "_")
rownames(taxonomy_amf_filtered) <- paste("amf", rownames(taxonomy_amf_filtered), sep = "_")

# 例: 68個のサンプル名を作成
new_row_names <- paste0("CSM_", sprintf("%02d", 1:68))
rownames(asv_fungi_filtered) <- new_row_names
rownames(asv_bacteria_filtered) <- new_row_names
rownames(picrust2_filtered) <- new_row_names
rownames(asv_amf_filtered) <- new_row_names
rownames(sample_info) <- new_row_names

# Sample informationの取得
sample_info <- as.data.frame(sample_info)  # 確認用にデータフレームに変換

# site毎にデータを二分化
ground_samples <- rownames(sample_info[sample_info$site == "ground", ])
canopy_samples <- rownames(sample_info[sample_info$site == "canopy", ])

# ASVデータを分ける
asv_fungi_ground <- asv_fungi_filtered[ground_samples, ]
asv_fungi_canopy <- asv_fungi_filtered[canopy_samples, ]
asv_bacteria_ground <- asv_bacteria_filtered[ground_samples, ]
asv_bacteria_canopy <- asv_bacteria_filtered[canopy_samples, ]
picrust2_ground <- picrust2_filtered[ground_samples, ]
picrust2_canopy <- picrust2_filtered[canopy_samples, ]
asv_amf_ground <- asv_amf_filtered[ground_samples, ]
asv_amf_canopy <- asv_amf_filtered[canopy_samples, ]
######ここでASVデータが場所毎に分かれている#######################################

# 相関行列を計算_ground###
combined_ground_table <- cbind(asv_fungi_ground, asv_bacteria_ground)
combined_ground_fa_table <- cbind(asv_fungi_ground, asv_amf_ground)
combined_ground_ba_table <- cbind(asv_bacteria_ground, asv_amf_ground)
combined_ground_fa_fun_table <- cbind(asv_fungi_ground, picrust2_ground)
combined_ground_everything <- cbind(asv_fungi_ground, asv_bacteria_ground, asv_amf_ground)

##以下、真菌＊細菌用のコード
# 列ごとの標準偏差を計算
sd_cols_ground <- apply(combined_ground_table, 2, sd)
sd_cols_ground_fa <- apply(combined_ground_fa_table, 2, sd)
sd_cols_ground_ba <- apply(combined_ground_ba_table, 2, sd)
sd_cols_ground_fa_fun <- apply(combined_ground_fa_fun_table, 2, sd)
sd_cols_ground_everything <- apply(combined_ground_everything, 2, sd)

# 標準偏差がゼロの列を削除
combined_ground_table_filtered <- combined_ground_table[, sd_cols_ground != 0]
combined_ground_fa_table_filtered <- combined_ground_fa_table[, sd_cols_ground_fa != 0]
combined_ground_ba_table_filtered <- combined_ground_ba_table[, sd_cols_ground_ba != 0]
combined_ground_fa_fun_table_filtered <- combined_ground_fa_fun_table[, sd_cols_ground_fa_fun != 0]
combined_ground_everything_filtered <- combined_ground_everything[, sd_cols_ground_everything != 0]

# 相関行列の計算（スピアマン相関）
correlation_ground_matrix <- cor(combined_ground_table_filtered, method = "spearman")
correlation_ground_fa_matrix <- cor(combined_ground_fa_table_filtered, method = "spearman")
correlation_ground_ba_matrix <- cor(combined_ground_ba_table_filtered, method = "spearman")
correlation_ground_fa_fun_matrix <- cor(combined_ground_fa_fun_table_filtered, method = "spearman")
correlation_ground_everything_matrix <- cor(combined_ground_everything_filtered, method = "spearman")

# 相関行列を計算_canopy
combined_canopy_table <- cbind(asv_fungi_canopy, asv_bacteria_canopy)
combined_canopy_fa_table <- cbind(asv_fungi_canopy, asv_amf_canopy)
combined_canopy_ba_table <- cbind(asv_bacteria_canopy, asv_amf_canopy)
combined_canopy_fa_fun_table <- cbind(asv_fungi_canopy, picrust2_canopy)

combined_canopy_everything <- cbind(asv_fungi_canopy, asv_bacteria_canopy, asv_amf_canopy)

##以下、真菌＊細菌用のコード
# 列ごとの標準偏差を計算
sd_cols_canopy <- apply(combined_canopy_table, 2, sd)
sd_cols_canopy_fa <- apply(combined_canopy_fa_table, 2, sd)
sd_cols_canopy_ba <- apply(combined_canopy_ba_table, 2, sd)
sd_cols_canopy_fa_fun <- apply(combined_canopy_fa_fun_table, 2, sd)
sd_cols_canopy_everything <- apply(combined_canopy_everything, 2, sd)
# 標準偏差がゼロの列を削除
combined_canopy_table_filtered <- combined_canopy_table[, sd_cols_canopy != 0]
combined_canopy_fa_table_filtered <- combined_canopy_fa_table[, sd_cols_canopy_fa != 0]
combined_canopy_ba_table_filtered <- combined_canopy_ba_table[, sd_cols_canopy_ba != 0]
combined_canopy_fa_fun_table_filtered <- combined_canopy_fa_fun_table[, sd_cols_canopy_fa_fun != 0]
combined_canopy_everything_filtered <- combined_canopy_everything[, sd_cols_canopy_everything != 0]
# 相関行列の計算（スピアマン相関）
correlation_canopy_matrix <- cor(combined_canopy_table_filtered, method = "spearman")
correlation_canopy_fa_matrix <- cor(combined_canopy_fa_table_filtered, method = "spearman")
correlation_canopy_ba_matrix <- cor(combined_canopy_ba_table_filtered, method = "spearman")
correlation_canopy_fa_fun_matrix <- cor(combined_canopy_fa_fun_table_filtered, method = "spearman")
correlation_canopy_everything_matrix <- cor(combined_canopy_everything_filtered, method = "spearman")
#TWINSPAN用
# グループごとの行名を定義
group_A <- c(25, 26, 27, 28, 29, 42, 43, 44, 45, 47, 48, 49, 53, 54, 55, 59, 60, 61)
group_B <- c(35, 37, 38, 39, 40, 41, 65, 66)
group_C <- c(31, 32, 36, 46, 52, 56, 57, 63, 67, 68)
group_D <- c(33, 50, 51, 58, 62)

# `CSM_` を付けて行名を作成
rownames_A <- paste0("CSM_", sprintf("%02d", group_A))
rownames_B <- paste0("CSM_", sprintf("%02d", group_B))
rownames_C <- paste0("CSM_", sprintf("%02d", group_C))
rownames_D <- paste0("CSM_", sprintf("%02d", group_D))

# グループごとにデータフレームを抽出_for_everything
combined_canopy_everythinhg_table_A <- combined_canopy_everything[rownames(combined_canopy_everything) %in% rownames_A, ]
combined_canopy_everythinhg_table_B <- combined_canopy_everything[rownames(combined_canopy_everything) %in% rownames_B, ]
combined_canopy_everythinhg_table_C <- combined_canopy_everything[rownames(combined_canopy_everything) %in% rownames_C, ]
combined_canopy_everythinhg_table_D <- combined_canopy_everything[rownames(combined_canopy_everything) %in% rownames_D, ]

sd_cols_A_canopy <- apply(combined_canopy_everythinhg_table_A , 2, sd)
combined_canopy_everything_table_filtered_A <- combined_canopy_everythinhg_table_A [, sd_cols_A_canopy != 0]
sd_cols_B_canopy <- apply(combined_canopy_everythinhg_table_B , 2, sd)
combined_canopy_everything_table_filtered_B <- combined_canopy_everythinhg_table_B [, sd_cols_B_canopy != 0]
sd_cols_C_canopy <- apply(combined_canopy_everythinhg_table_C , 2, sd)
combined_canopy_everything_table_filtered_C <- combined_canopy_everythinhg_table_C [, sd_cols_C_canopy != 0]
sd_cols_D_canopy <- apply(combined_canopy_everythinhg_table_D , 2, sd)
combined_canopy_everything_table_filtered_D <- combined_canopy_everythinhg_table_D [, sd_cols_D_canopy != 0]

# 相関行列の計算（スピアマン相関）
correlation_canopy_everything_A_matrix <- cor(combined_canopy_everything_table_filtered_A, method = "spearman")
correlation_canopy_everything_B_matrix <- cor(combined_canopy_everything_table_filtered_B, method = "spearman")
correlation_canopy_everything_C_matrix <- cor(combined_canopy_everything_table_filtered_C, method = "spearman")
correlation_canopy_everything_D_matrix <- cor(combined_canopy_everything_table_filtered_D, method = "spearman")

# グループごとにデータフレームを抽出_for_FB
combined_canopy_table_A <- combined_canopy_table[rownames(combined_canopy_table) %in% rownames_A, ]
combined_canopy_table_B <- combined_canopy_table[rownames(combined_canopy_table) %in% rownames_B, ]
combined_canopy_table_C <- combined_canopy_table[rownames(combined_canopy_table) %in% rownames_C, ]
combined_canopy_table_D <- combined_canopy_table[rownames(combined_canopy_table) %in% rownames_D, ]

sd_cols_A_canopy <- apply(combined_canopy_table_A , 2, sd)
combined_canopy_table_filtered_A <- combined_canopy_table_A [, sd_cols_A_canopy != 0]

sd_cols_B_canopy <- apply(combined_canopy_table_B , 2, sd)
combined_canopy_table_filtered_B <- combined_canopy_table_B [, sd_cols_B_canopy != 0]

sd_cols_C_canopy <- apply(combined_canopy_table_C , 2, sd)
combined_canopy_table_filtered_C <- combined_canopy_table_C [, sd_cols_C_canopy != 0]

sd_cols_D_canopy <- apply(combined_canopy_table_D , 2, sd)
combined_canopy_table_filtered_D <- combined_canopy_table_D [, sd_cols_D_canopy != 0]

# 相関行列の計算（スピアマン相関）
correlation_canopy_A_matrix <- cor(combined_canopy_table_filtered_A, method = "spearman")
correlation_canopy_B_matrix <- cor(combined_canopy_table_filtered_B, method = "spearman")
correlation_canopy_C_matrix <- cor(combined_canopy_table_filtered_C, method = "spearman")
correlation_canopy_D_matrix <- cor(combined_canopy_table_filtered_D, method = "spearman")

# グループごとにデータフレームを抽出_for_FA
combined_canopy_fa_table_A <- combined_canopy_fa_table[rownames(combined_canopy_fa_table) %in% rownames_A, ]
combined_canopy_fa_table_B <- combined_canopy_fa_table[rownames(combined_canopy_fa_table) %in% rownames_B, ]
combined_canopy_fa_table_C <- combined_canopy_fa_table[rownames(combined_canopy_fa_table) %in% rownames_C, ]
combined_canopy_fa_table_D <- combined_canopy_fa_table[rownames(combined_canopy_fa_table) %in% rownames_D, ]

sd_cols_A_canopy <- apply(combined_canopy_fa_table_A , 2, sd)
combined_canopy_fa_table_filtered_A <- combined_canopy_fa_table_A [, sd_cols_A_canopy != 0]

sd_cols_B_canopy <- apply(combined_canopy_fa_table_B , 2, sd)
combined_canopy_fa_table_filtered_B <- combined_canopy_fa_table_B [, sd_cols_B_canopy != 0]

sd_cols_C_canopy <- apply(combined_canopy_fa_table_C , 2, sd)
combined_canopy_fa_table_filtered_C <- combined_canopy_fa_table_C [, sd_cols_C_canopy != 0]

sd_cols_D_canopy <- apply(combined_canopy_fa_table_D, 2, sd)
combined_canopy_fa_table_filtered_D <- combined_canopy_fa_table_D [, sd_cols_D_canopy != 0]

# 相関行列の計算（スピアマン相関）
correlation_canopy_fa_A_matrix <- cor(combined_canopy_fa_table_filtered_A, method = "spearman")
correlation_canopy_fa_B_matrix <- cor(combined_canopy_fa_table_filtered_B, method = "spearman")
correlation_canopy_fa_C_matrix <- cor(combined_canopy_fa_table_filtered_C, method = "spearman")
correlation_canopy_fa_D_matrix <- cor(combined_canopy_fa_table_filtered_D, method = "spearman")

# グループごとにデータフレームを抽出_for_BA
combined_canopy_ba_table_A <- combined_canopy_ba_table[rownames(combined_canopy_ba_table) %in% rownames_A, ]
combined_canopy_ba_table_B <- combined_canopy_ba_table[rownames(combined_canopy_ba_table) %in% rownames_B, ]
combined_canopy_ba_table_C <- combined_canopy_ba_table[rownames(combined_canopy_ba_table) %in% rownames_C, ]
combined_canopy_ba_table_D <- combined_canopy_ba_table[rownames(combined_canopy_ba_table) %in% rownames_D, ]

sd_cols_A_canopy <- apply(combined_canopy_ba_table_A , 2, sd)
combined_canopy_ba_table_filtered_A <- combined_canopy_ba_table_A [, sd_cols_A_canopy != 0]

sd_cols_B_canopy <- apply(combined_canopy_ba_table_B , 2, sd)
combined_canopy_ba_table_filtered_B <- combined_canopy_ba_table_B [, sd_cols_B_canopy != 0]

sd_cols_C_canopy <- apply(combined_canopy_ba_table_C , 2, sd)
combined_canopy_ba_table_filtered_C <- combined_canopy_ba_table_C [, sd_cols_C_canopy != 0]

sd_cols_D_canopy <- apply(combined_canopy_ba_table_D, 2, sd)
combined_canopy_ba_table_filtered_D <- combined_canopy_ba_table_D [, sd_cols_D_canopy != 0]

# 相関行列の計算（スピアマン相関）
correlation_canopy_ba_A_matrix <- cor(combined_canopy_ba_table_filtered_A, method = "spearman")
correlation_canopy_ba_B_matrix <- cor(combined_canopy_ba_table_filtered_B, method = "spearman")
correlation_canopy_ba_C_matrix <- cor(combined_canopy_ba_table_filtered_C, method = "spearman")
correlation_canopy_ba_D_matrix <- cor(combined_canopy_ba_table_filtered_D, method = "spearman")


##########################################################################################################################################################
##### 真菌＊細菌＊AMF #############################################################################################################################
##ground#######
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_ground_everything_filtered) %in% colnames(asv_fungi_ground))
n_bacteria_filtered <- sum(colnames(combined_ground_everything_filtered) %in% colnames(asv_bacteria_ground))
n_amf_filtered <- sum(colnames(combined_ground_everything_filtered) %in% colnames(asv_amf_ground))

# 相関行列を分割
fungi_corr <- correlation_ground_everything_matrix[1:n_fungi_filtered, 1:n_fungi_filtered]
bacteria_corr <- correlation_ground_everything_matrix[
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)
]
amf_corr <- correlation_ground_everything_matrix[
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered),
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]

fungi_bacteria_corr <- correlation_ground_everything_matrix[1:n_fungi_filtered,
                                                            (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)
]
fungi_amf_corr <- correlation_ground_everything_matrix[1:n_fungi_filtered,
                                                       (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]
bacteria_amf_corr <- correlation_ground_everything_matrix[
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]

# 隣接行列の作成（相関係数が0.6以上の場合に1を設定）
adjacency_fungi <- ifelse(fungi_corr >= 0.6, 1, 0)
adjacency_bacteria <- ifelse(bacteria_corr >= 0.6, 1, 0)
adjacency_amf <- ifelse(amf_corr >= 0.6, 1, 0)

adjacency_fungi_bacteria <- ifelse(fungi_bacteria_corr >= 0.6, 1, 0)
adjacency_fungi_amf <- ifelse(fungi_amf_corr >= 0.6, 1, 0)
adjacency_bacteria_amf <- ifelse(bacteria_amf_corr >= 0.6, 1, 0)

# 全体の隣接行列を構築
total_nodes <- n_fungi_filtered + n_bacteria_filtered + n_amf_filtered
adjacency_matrix <- matrix(0, nrow = total_nodes, ncol = total_nodes)
# 全ノードの名前を作成
fungi_names <- fungi_names <- colnames(combined_ground_everything_filtered)[colnames(combined_ground_everything_filtered) %in% colnames(asv_fungi_ground)]
bacteria_names <- colnames(combined_ground_everything_filtered)[colnames(combined_ground_everything_filtered) %in% colnames(asv_bacteria_ground)]
amf_names <- colnames(combined_ground_everything_filtered)[colnames(combined_ground_everything_filtered) %in% colnames(asv_amf_ground)]
# 名前を結合して全体のノード名を作成
all_node_names <- c(fungi_names, bacteria_names, amf_names)
# adjacency_matrix に行名と列名を追加
rownames(adjacency_matrix) <- all_node_names
colnames(adjacency_matrix) <- all_node_names

# 真菌、細菌、AMFの自己相関を設定
adjacency_matrix[1:n_fungi_filtered, 1:n_fungi_filtered] <- adjacency_fungi
adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- adjacency_bacteria
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_amf

# グループ間の相関を設定
adjacency_matrix[1:n_fungi_filtered, 
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- adjacency_fungi_bacteria
adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
                 1:n_fungi_filtered] <- t(adjacency_fungi_bacteria)

adjacency_matrix[1:n_fungi_filtered, 
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_fungi_amf
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 1:n_fungi_filtered] <- t(adjacency_fungi_amf)

adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered), 
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_bacteria_amf
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- t(adjacency_bacteria_amf)
diag(adjacency_matrix) <- 0

# igraphオブジェクトを作成
g_ground_total <- graph_from_adjacency_matrix(adjacency_matrix, mode = "undirected")
 
# 1. 暖色系のカラーパレットを指定,"fungi", "bacteria", "amf" の色を指定
palette_warm <- brewer.pal(3, "Set2")  # "Oranges" を使用（3色）
color_fungi <- palette_warm[1]  # 一番薄い色
color_bacteria <- palette_warm[2]  # 中間の色
color_amf <- palette_warm[3]  # 一番濃い色

# 2. ノードごとに対応する色を割り当て
node_colors <- sapply(V(g_ground_total)$name, function(node_name) {
  if (node_name %in% fungi_names) {
    return(color_fungi)
  } else if (node_name %in% bacteria_names) {
    return(color_bacteria)
  } else if (node_name %in% amf_names) {
    return(color_amf)
  } else {
    return(NA)  # 該当しない場合は NA
  }
})

# 3. ノードの形を設定
node_shapes <- sapply(V(g_ground_total)$name, function(node_name) {
  if (node_name %in% fungi_names) {
    return("square")
  } else if (node_name %in% bacteria_names) {
    return("circle")
  } else if (node_name %in% amf_names) {
    return("csquare")
  } else {
    return(NA)  # 該当しない場合は NA
  }
})

# 4. エッジのないノードを削除
g_ground_total <- delete_vertices(g_ground_total, degree(g_ground_total) == 0)

set.seed(10)

# 5. ノードの設定をプロットに反映
plot(
  g_ground_total,
  vertex.color = adjustcolor(node_colors, alpha.f = 0.7),  # 色を設定
  vertex.shape = node_shapes,  # 形を設定
  vertex.size = log(degree(g_ground_total) + 1) * 3,  # ノードサイズ（例として対数スケーリング）
  edge.width = 2,  # エッジの太さ
  vertex.label = NA  # ラベルは非表示
)

# 6. 凡例を追加
legend("topright", 
       legend = c("Fungi", "Bacteria", "AMF"), 
       fill = adjustcolor(c(color_fungi, color_bacteria, color_amf), alpha.f = 0.7),
       title = "Node Type", 
       border = "black", 
       bty = "n", 
       cex = 1.5, 
       pt.cex = 2)



# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_ground_class <- taxonomy_fungi_filtered[fungi_names, "Class"]
taxonomy_bacteria_ground_class <- taxonomy_bacteria_filtered[bacteria_names, "Class"]
taxonomy_amf_ground_species <- taxonomy_amf_filtered[amf_names, "Species"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_ground_class)
unique_bacteria_classes <- unique(taxonomy_bacteria_ground_class)
unique_amf_species <- unique(taxonomy_amf_ground_species)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "BuGn"))(length(unique_fungi_classes))  
palette_bacteria <- colorRampPalette(brewer.pal(9, "PuBu"))(length(unique_bacteria_classes)) 
palette_amf <- colorRampPalette(brewer.pal(9, "YlOrRd"))(length(unique_amf_species)) 

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)
species_colors_amf <- setNames(palette_amf, unique_amf_species)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_ground_class]
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_ground_class]
node_colors_amf <- species_colors_amf[taxonomy_amf_ground_species]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_bacteria, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_names))       # 真菌のノードの形
shapes_bacteria <- rep("square", length(bacteria_names))  # バクテリアのノードの形
shapes_amf <- rep("crectangle", length(amf_names))  # amfのノードの形
node_shapes <- c(shapes_fungi, shapes_bacteria, shapes_amf)

# 8. エッジのないノードを削除
g_ground_total <- delete_vertices(g_ground_total, degree(g_ground_total) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_ground_total)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_names) {
    return(class_colors_fungi[taxonomy_fungi_ground_class[match(node_name, fungi_names)]])
  } else if (node_name %in% bacteria_names) {
    return(class_colors_bacteria[taxonomy_bacteria_ground_class[match(node_name, bacteria_names)]])
  } else if (node_name %in% amf_names) {
    return(species_colors_amf[taxonomy_amf_ground_species[match(node_name, amf_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_names))
remaining_node_shapes_bacteria <- rep("square", sum(remaining_node_names %in% bacteria_names))
remaining_node_shapes_amf <- rep("csquare", sum(remaining_node_names %in% amf_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_bacteria, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_ground_total)

# 各ノードの次数を取得
node_degrees <- degree(g_ground_total)

# ノードのサイズを平方根スケーリングで調整
V(g_ground_total)$size <- log(node_degrees + 1) * 2  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_ground_total, 
     layout = layout,
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.5),  # ノードの色と透明度
     vertex.size = V(g_ground_total)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("1209_ground_everything_class&species_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_bacteria_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# AMFの凡例を右下に配置
legend("bottomright", 
       legend = unique_amf_species,  # AMFのカテゴリ名
       fill = adjustcolor(species_colors_amf[unique_amf_species], alpha.f = 0.7),  # AMFの対応する色
       title = "AMF species",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()



# 各ノードの次数を計算
node_degrees <- degree(g_ground_total)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_ground_total)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_ground_everything_0.6_ranking.csv", row.names = FALSE)

# 元のデータフレームをコピー
taxonomy_bacteria_filtered_added <- taxonomy_bacteria_filtered
# 新しい列 "Species" を追加
taxonomy_bacteria_filtered_added$Species <- NA  # NAで初期化
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_fungi_filtered, taxonomy_bacteria_filtered_added, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_ground_everything_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

##### Module解析 for 三部グラフ ########
# Louvain法によるモジュール検出（全三部グラフに対して）
tri_partite_clusters <- cluster_louvain(g_ground_total)
# モジュール度（modularity）の計算
modularity_total <- modularity(tri_partite_clusters)
# 結果を表示
cat("三部グラフ全体のモジュール度:", modularity_total, "\n")
# コミュニティごとのメンバーシップを取得
membership_total <- membership(tri_partite_clusters)
# コミュニティに応じたノードの色を割り当て
community_colors <- rainbow(max(membership_total))
node_colors <- community_colors[membership_total]

set.seed(10)

# 三部グラフのプロット（コミュニティごとの色分け）
plot(g_ground_total, 
     layout = layout_with_fr(g_ground_total),  # Fruchterman-Reingoldレイアウト
     vertex.color = node_colors,  # コミュニティごとの色分け
     vertex.size = V(g_ground_total)$size,  # ノードサイズ
     vertex.shape = node_shapes,  # ノードの形
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
library(bipartite)
library(igraph)

# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
observed_connectance <- networklevel(adjacency_matrix, index = "connectance", weighted = TRUE)
print(observed_connectance)
# 入れ子度（NODF）の計算
observed_nodf <- nested(adjacency_matrix, method = "NODF")
print(observed_nodf)
# 相互作用特殊化度 (H2') の計算
observed_H2_value <- H2fun(adjacency_matrix, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(observed_H2_value)
# 各指標の実行
observed_edge_density <- edge_density(g_ground_total)
observed_edge_count <- ecount(g_ground_total)
observed_global_clustering <- transitivity(g_ground_total, type = "global")
observed_max_degree <- max(degrees)
observed_mean_degree <- mean(degrees)
observed_num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", observed_edge_density, "\n")
cat("エッジ数:", observed_edge_count, "\n")
cat("グローバルクラスタリング係数:", observed_global_clustering, "\n")
cat("最大degree数:", observed_max_degree, "\n")
cat("平均degree数:", observed_mean_degree, "\n")
cat("エッジ数10以上のノード数:", observed_num_high_degree_nodes, "\n")

#null model

# 指標を格納するためのベクトルを作成
random_connectance <- numeric(100)
random_nodf <- numeric(100)
random_modularity <- numeric(100)
random_h2 <- numeric(100)
random_edge_density <- numeric(100)
random_edge_count <- numeric(100)
random_global_clustering <- numeric(100)
random_max_degree <- numeric(100)
random_mean_degree <- numeric(100)
random_num_high_degree_nodes <- numeric(100)

set.seed(NULL)
for (i in 1:25) {
  # ランダムな三部グラフを生成
  random_graph <- erdos.renyi.game(vcount(g_ground_total), ecount(g_ground_total), type = "gnm")
  
  # ランダムグラフの品質チェック
  if (ecount(random_graph) == 0) next
  
  # 隣接行列を取得
  null_matrix <- as_adjacency_matrix(random_graph, sparse = FALSE)
  
  # 指標を計算
  random_modularity[i] <- modularity(cluster_louvain(random_graph))
  random_connectance[i] <- networklevel(null_matrix, index = "connectance", weighted = TRUE)
  random_nodf[i] <- nested(null_matrix, method = "NODF")
  #random_h2[i] <- H2fun(null_matrix, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
  random_edge_density[i] <- edge_density(random_graph)
  random_global_clustering[i] <- transitivity(random_graph, type = "global")
}

# Null Modelの平均と標準偏差を計算
mean_random_modularity <- mean(random_modularity)
sd_random_modularity <- sd(random_modularity)
mean_random_connectance <- mean(random_connectance)
sd_random_connectance <- sd(random_connectance)
mean_random_nodf <- mean(random_nodf)
sd_random_nodf <- sd(random_nodf)
mean_random_edge_density <- mean(random_edge_density)
sd_random_edge_density <- sd(random_edge_density)
mean_random_global_clustering <- mean(random_global_clustering)
sd_random_global_clustering <- sd(random_global_clustering)

# zスコアを計算
if (sd_random_modularity == 0) {
  z_modularity <- NA
} else {
  z_modularity <- (observed_modularity - mean_random_modularity) / sd_random_modularity
}
if (sd_random_connectance == 0) {
  z_connectance <- NA
} else {
  z_connectance <- (observed_connectance - mean_random_connectance) / sd_random_connectance
}
if (sd_random_nodf == 0) {
  z_nodf <- NA
} else {
  z_nodf <- (observed_nodf - mean_random_nodf) / sd_random_nodf
}
if (sd_random_edge_density == 0) {
  z_edge_density <- NA
} else {
  z_edge_density <- (observed_edge_density - mean_random_edge_density) / sd_random_edge_density
}
if (sd_random_global_clustering == 0) {
  z_connectance <- NA
} else {
  z_clustering <- (observed_clustering - mean_random_global_clustering) / sd_random_global_clustering
}

# p値を計算（片側検定）
p_modularity <- 2 * (1 - pnorm(abs(z_modularity)))
p_connectance <- 2 * (1 - pnorm(abs(z_connectance)))
p_nodf <- 2 * (1 - pnorm(abs(z_nodf)))
p_edge_density <- 2 * (1 - pnorm(abs(z_edge_density)))
p_clustering <- 2 * (1 - pnorm(abs(z_clustering)))

# 結果を表示
cat("モジュール度: zスコア =", z_modularity, ", p値 =", p_modularity, "\n")
cat("モジュール度: zスコア =", z_connectance, ", p値 =", p_connectance, "\n")
cat("モジュール度: zスコア =", z_nodf, ", p値 =", p_nodf, "\n")
cat("エッジ密度: zスコア =", z_edge_density, ", p値 =", p_edge_density, "\n")
cat("クラスタリング係数: zスコア =", z_clustering, ", p値 =", p_clustering, "\n")



###canopy####
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_canopy_everything_filtered) %in% colnames(asv_fungi_canopy))
n_bacteria_filtered <- sum(colnames(combined_canopy_everything_filtered) %in% colnames(asv_bacteria_canopy))
n_amf_filtered <- sum(colnames(combined_canopy_everything_filtered) %in% colnames(asv_amf_canopy))

# 相関行列を分割
fungi_corr <- correlation_canopy_everything_matrix[1:n_fungi_filtered, 1:n_fungi_filtered]
bacteria_corr <- correlation_canopy_everything_matrix[
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)
]
amf_corr <- correlation_canopy_everything_matrix[
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered),
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]

fungi_bacteria_corr <- correlation_canopy_everything_matrix[1:n_fungi_filtered,
                                                            (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)
]
fungi_amf_corr <- correlation_canopy_everything_matrix[1:n_fungi_filtered,
                                                       (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]
bacteria_amf_corr <- correlation_canopy_everything_matrix[
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]

# 隣接行列の作成（相関係数が0.6以上の場合に1を設定）
adjacency_fungi <- ifelse(fungi_corr >= 0.6, 1, 0)
adjacency_bacteria <- ifelse(bacteria_corr >= 0.6, 1, 0)
adjacency_amf <- ifelse(amf_corr >= 0.6, 1, 0)

adjacency_fungi_bacteria <- ifelse(fungi_bacteria_corr >= 0.6, 1, 0)
adjacency_fungi_amf <- ifelse(fungi_amf_corr >= 0.6, 1, 0)
adjacency_bacteria_amf <- ifelse(bacteria_amf_corr >= 0.6, 1, 0)

# 全体の隣接行列を構築
total_nodes <- n_fungi_filtered + n_bacteria_filtered + n_amf_filtered
adjacency_matrix <- matrix(0, nrow = total_nodes, ncol = total_nodes)
# 全ノードの名前を作成
fungi_names <- colnames(combined_canopy_everything_filtered)[colnames(combined_canopy_everything_filtered) %in% colnames(asv_fungi_canopy)]
bacteria_names <- colnames(combined_canopy_everything_filtered)[colnames(combined_canopy_everything_filtered) %in% colnames(asv_bacteria_canopy)]
amf_names <- colnames(combined_canopy_everything_filtered)[colnames(combined_canopy_everything_filtered) %in% colnames(asv_amf_canopy)]
# 名前を結合して全体のノード名を作成
all_node_names <- c(fungi_names, bacteria_names, amf_names)
# adjacency_matrix に行名と列名を追加
rownames(adjacency_matrix) <- all_node_names
colnames(adjacency_matrix) <- all_node_names

# 真菌、細菌、AMFの自己相関を設定
adjacency_matrix[1:n_fungi_filtered, 1:n_fungi_filtered] <- adjacency_fungi
adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- adjacency_bacteria
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_amf

# グループ間の相関を設定
adjacency_matrix[1:n_fungi_filtered, 
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- adjacency_fungi_bacteria
adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
                 1:n_fungi_filtered] <- t(adjacency_fungi_bacteria)

adjacency_matrix[1:n_fungi_filtered, 
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_fungi_amf
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 1:n_fungi_filtered] <- t(adjacency_fungi_amf)

adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered), 
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_bacteria_amf
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- t(adjacency_bacteria_amf)
diag(adjacency_matrix) <- 0

# igraphオブジェクトを作成
g_canopy_total <- graph_from_adjacency_matrix(adjacency_matrix, mode = "undirected")

# 1. 暖色系のカラーパレットを指定,"fungi", "bacteria", "amf" の色を指定
palette_warm <- brewer.pal(3, "Set2")  # "Oranges" を使用（3色）
color_fungi <- palette_warm[1]  # 一番薄い色
color_bacteria <- palette_warm[2]  # 中間の色
color_amf <- palette_warm[3]  # 一番濃い色

# 2. ノードごとに対応する色を割り当て
node_colors <- sapply(V(g_canopy_total)$name, function(node_name) {
  if (node_name %in% fungi_names) {
    return(color_fungi)
  } else if (node_name %in% bacteria_names) {
    return(color_bacteria)
  } else if (node_name %in% amf_names) {
    return(color_amf)
  } else {
    return(NA)  # 該当しない場合は NA
  }
})

# 3. ノードの形を設定
node_shapes <- sapply(V(g_canopy_total)$name, function(node_name) {
  if (node_name %in% fungi_names) {
    return("square")
  } else if (node_name %in% bacteria_names) {
    return("circle")
  } else if (node_name %in% amf_names) {
    return("csquare")
  } else {
    return(NA)  # 該当しない場合は NA
  }
})

# 4. エッジのないノードを削除
g_canopy_total <- delete_vertices(g_canopy_total, degree(g_canopy_total) == 0)

set.seed(10)

# 5. ノードの設定をプロットに反映
plot(
  g_canopy_total,
  vertex.color = adjustcolor(node_colors, alpha.f = 0.7),  # 色を設定
  vertex.shape = node_shapes,  # 形を設定
  vertex.size = log(degree(g_canopy_total) + 1) * 3,  # ノードサイズ（例として対数スケーリング）
  edge.width = 2,  # エッジの太さ
  vertex.label = NA  # ラベルは非表示
)

# 6. 凡例を追加
legend("topright", 
       legend = c("Fungi", "Bacteria", "AMF"), 
       fill = adjustcolor(c(color_fungi, color_bacteria, color_amf), alpha.f = 0.7),
       title = "Node Type", 
       border = "black", 
       bty = "n", 
       cex = 1.5, 
       pt.cex = 2)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_ground_class <- taxonomy_fungi_filtered[fungi_names, "Class"]
taxonomy_bacteria_ground_class <- taxonomy_bacteria_filtered[bacteria_names, "Class"]
taxonomy_amf_ground_species <- taxonomy_amf_filtered[amf_names, "Species"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_ground_class)
unique_bacteria_classes <- unique(taxonomy_bacteria_ground_class)
unique_amf_species <- unique(taxonomy_amf_ground_species)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "BuGn"))(length(unique_fungi_classes))  
palette_bacteria <- colorRampPalette(brewer.pal(9, "PuBu"))(length(unique_bacteria_classes)) 
palette_amf <- colorRampPalette(brewer.pal(9, "YlOrRd"))(length(unique_amf_species)) 

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)
species_colors_amf <- setNames(palette_amf, unique_amf_species)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_ground_class]
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_ground_class]
node_colors_amf <- species_colors_amf[taxonomy_amf_ground_species]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_bacteria, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_names))       # 真菌のノードの形
shapes_bacteria <- rep("square", length(bacteria_names))  # バクテリアのノードの形
shapes_amf <- rep("crectangle", length(amf_names))  # amfのノードの形
node_shapes <- c(shapes_fungi, shapes_bacteria, shapes_amf)

# 8. エッジのないノードを削除
g_ground_total <- delete_vertices(g_ground_total, degree(g_ground_total) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_ground_total)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_names) {
    return(class_colors_fungi[taxonomy_fungi_ground_class[match(node_name, fungi_names)]])
  } else if (node_name %in% bacteria_names) {
    return(class_colors_bacteria[taxonomy_bacteria_ground_class[match(node_name, bacteria_names)]])
  } else if (node_name %in% amf_names) {
    return(species_colors_amf[taxonomy_amf_ground_species[match(node_name, amf_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_names))
remaining_node_shapes_bacteria <- rep("square", sum(remaining_node_names %in% bacteria_names))
remaining_node_shapes_amf <- rep("csquare", sum(remaining_node_names %in% amf_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_bacteria, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_ground_total)

# 各ノードの次数を取得
node_degrees <- degree(g_ground_total)

# ノードのサイズを平方根スケーリングで調整
V(g_ground_total)$size <- log(node_degrees + 1) * 2  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_ground_total, 
     layout = layout,
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.5),  # ノードの色と透明度
     vertex.size = V(g_ground_total)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("1209_ground_everything_class&species_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_bacteria_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# AMFの凡例を右下に配置
legend("bottomright", 
       legend = unique_amf_species,  # AMFのカテゴリ名
       fill = adjustcolor(species_colors_amf[unique_amf_species], alpha.f = 0.7),  # AMFの対応する色
       title = "AMF species",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_total)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_total)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_canopy_everything_0.6_ranking.csv", row.names = FALSE)

# 元のデータフレームをコピー
#taxonomy_bacteria_filtered_added <- taxonomy_bacteria_filtered
# 新しい列 "Species" を追加
#taxonomy_bacteria_filtered_added$Species <- NA  # NAで初期化
# タクソノミー情報を結合
#taxonomy_combined <- rbind(taxonomy_fungi_filtered, taxonomy_bacteria_filtered_added, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
#taxonomy_combined_with_asv <- taxonomy_combined %>%
#  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_canopy_everything_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

##### Module解析 for 三部グラフ ########
# Louvain法によるモジュール検出（全三部グラフに対して）
tri_partite_clusters <- cluster_louvain(g_canopy_total)
# モジュール度（modularity）の計算
modularity_total <- modularity(tri_partite_clusters)
# 結果を表示
cat("三部グラフ全体のモジュール度:", modularity_total, "\n")
# コミュニティごとのメンバーシップを取得
membership_total <- membership(tri_partite_clusters)
# コミュニティに応じたノードの色を割り当て
community_colors <- rainbow(max(membership_total))
node_colors <- community_colors[membership_total]

set.seed(10)

# 三部グラフのプロット（コミュニティごとの色分け）
plot(g_canopy_total, 
     layout = layout_with_fr(g_canopy_total),  # Fruchterman-Reingoldレイアウト
     vertex.color = node_colors,  # コミュニティごとの色分け
     vertex.size = log(degree(g_canopy_total) + 1) * 3 ,  # ノードサイズ
     vertex.shape = node_shapes,  # ノードの形
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
library(bipartite)
library(igraph)

# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
observed_connectance <- networklevel(adjacency_matrix, index = "connectance", weighted = TRUE)
print(observed_connectance)
# 入れ子度（NODF）の計算
observed_nodf <- nested(adjacency_matrix, method = "NODF")
print(observed_nodf)
# 相互作用特殊化度 (H2') の計算
observed_H2_value <- H2fun(adjacency_matrix, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(observed_H2_value)
# 各指標の実行
observed_edge_density <- edge_density(g_canopy_total)
observed_edge_count <- ecount(g_canopy_total)
observed_global_clustering <- transitivity(g_canopy_total, type = "global")
degrees <- degree(g_canopy_total)
observed_max_degree <- max(degrees)
observed_mean_degree <- mean(degrees)
observed_num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", observed_edge_density, "\n")
cat("エッジ数:", observed_edge_count, "\n")
cat("グローバルクラスタリング係数:", observed_global_clustering, "\n")
cat("最大degree数:", observed_max_degree, "\n")
cat("平均degree数:", observed_mean_degree, "\n")
cat("エッジ数10以上のノード数:", observed_num_high_degree_nodes, "\n")

#null model

# 指標を格納するためのベクトルを作成
random_connectance <- numeric(100)
random_nodf <- numeric(100)
random_modularity <- numeric(100)
random_h2 <- numeric(100)
random_edge_density <- numeric(100)
random_edge_count <- numeric(100)
random_global_clustering <- numeric(100)
random_max_degree <- numeric(100)
random_mean_degree <- numeric(100)
random_num_high_degree_nodes <- numeric(100)

set.seed(NULL)
for (i in 1:25) {
  # ランダムな三部グラフを生成
  random_graph <- erdos.renyi.game(vcount(g_ground_total), ecount(g_ground_total), type = "gnm")
  
  # ランダムグラフの品質チェック
  if (ecount(random_graph) == 0) next
  
  # 隣接行列を取得
  null_matrix <- as_adjacency_matrix(random_graph, sparse = FALSE)
  
  # 指標を計算
  random_modularity[i] <- modularity(cluster_louvain(random_graph))
  random_connectance[i] <- networklevel(null_matrix, index = "connectance", weighted = TRUE)
  random_nodf[i] <- nested(null_matrix, method = "NODF")
  #random_h2[i] <- H2fun(null_matrix, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
  random_edge_density[i] <- edge_density(random_graph)
  random_global_clustering[i] <- transitivity(random_graph, type = "global")
}

# Null Modelの平均と標準偏差を計算
mean_random_modularity <- mean(random_modularity)
sd_random_modularity <- sd(random_modularity)
mean_random_connectance <- mean(random_connectance)
sd_random_connectance <- sd(random_connectance)
mean_random_nodf <- mean(random_nodf)
sd_random_nodf <- sd(random_nodf)
mean_random_edge_density <- mean(random_edge_density)
sd_random_edge_density <- sd(random_edge_density)
mean_random_global_clustering <- mean(random_global_clustering)
sd_random_global_clustering <- sd(random_global_clustering)

# zスコアを計算
if (sd_random_modularity == 0) {
  z_modularity <- NA
} else {
  z_modularity <- (observed_modularity - mean_random_modularity) / sd_random_modularity
}
if (sd_random_connectance == 0) {
  z_connectance <- NA
} else {
  z_connectance <- (observed_connectance - mean_random_connectance) / sd_random_connectance
}
if (sd_random_nodf == 0) {
  z_nodf <- NA
} else {
  z_nodf <- (observed_nodf - mean_random_nodf) / sd_random_nodf
}
if (sd_random_edge_density == 0) {
  z_edge_density <- NA
} else {
  z_edge_density <- (observed_edge_density - mean_random_edge_density) / sd_random_edge_density
}
if (sd_random_global_clustering == 0) {
  z_connectance <- NA
} else {
  z_clustering <- (observed_clustering - mean_random_global_clustering) / sd_random_global_clustering
}

# p値を計算（片側検定）
p_modularity <- 2 * (1 - pnorm(abs(z_modularity)))
p_connectance <- 2 * (1 - pnorm(abs(z_connectance)))
p_nodf <- 2 * (1 - pnorm(abs(z_nodf)))
p_edge_density <- 2 * (1 - pnorm(abs(z_edge_density)))
p_clustering <- 2 * (1 - pnorm(abs(z_clustering)))

# 結果を表示
cat("モジュール度: zスコア =", z_modularity, ", p値 =", p_modularity, "\n")
cat("モジュール度: zスコア =", z_connectance, ", p値 =", p_connectance, "\n")
cat("モジュール度: zスコア =", z_nodf, ", p値 =", p_nodf, "\n")
cat("エッジ密度: zスコア =", z_edge_density, ", p値 =", p_edge_density, "\n")
cat("クラスタリング係数: zスコア =", z_clustering, ", p値 =", p_clustering, "\n")
#### TWINASPAN A F*B ################################################################################
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_canopy_everything_table_filtered_A) %in% colnames(asv_fungi_canopy))
n_bacteria_filtered <- sum(colnames(combined_canopy_everything_table_filtered_A) %in% colnames(asv_bacteria_canopy))
n_amf_filtered <- sum(colnames(combined_canopy_everything_table_filtered_A) %in% colnames(asv_amf_canopy))

# 相関行列を分割
fungi_corr <- correlation_canopy_everything_A_matrix[1:n_fungi_filtered, 1:n_fungi_filtered]
bacteria_corr <- correlation_canopy_everything_A_matrix[
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)
]
amf_corr <- correlation_canopy_everything_A_matrix[
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered),
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]

fungi_bacteria_corr <- correlation_canopy_everything_A_matrix[1:n_fungi_filtered,
                                                            (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)
]
fungi_amf_corr <- correlation_canopy_everything_A_matrix[1:n_fungi_filtered,
                                                       (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]
bacteria_amf_corr <- correlation_canopy_everything_A_matrix[
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]

# 隣接行列の作成（相関係数が0.6以上の場合に1を設定）
adjacency_fungi <- ifelse(fungi_corr >= 0.6, 1, 0)
adjacency_bacteria <- ifelse(bacteria_corr >= 0.6, 1, 0)
adjacency_amf <- ifelse(amf_corr >= 0.6, 1, 0)

adjacency_fungi_bacteria <- ifelse(fungi_bacteria_corr >= 0.6, 1, 0)
adjacency_fungi_amf <- ifelse(fungi_amf_corr >= 0.6, 1, 0)
adjacency_bacteria_amf <- ifelse(bacteria_amf_corr >= 0.6, 1, 0)

# 全体の隣接行列を構築
total_nodes <- n_fungi_filtered + n_bacteria_filtered + n_amf_filtered
adjacency_matrix <- matrix(0, nrow = total_nodes, ncol = total_nodes)
# 全ノードの名前を作成
fungi_names <- colnames(combined_canopy_everything_table_filtered_A)[colnames(combined_canopy_everything_table_filtered_A) %in% colnames(asv_fungi_canopy)]
bacteria_names <- colnames(combined_canopy_everything_table_filtered_A)[colnames(combined_canopy_everything_table_filtered_A) %in% colnames(asv_bacteria_canopy)]
amf_names <- colnames(combined_canopy_everything_table_filtered_A)[colnames(combined_canopy_everything_table_filtered_A) %in% colnames(asv_amf_canopy)]
# 名前を結合して全体のノード名を作成
all_node_names <- c(fungi_names, bacteria_names, amf_names)
# adjacency_matrix に行名と列名を追加
rownames(adjacency_matrix) <- all_node_names
colnames(adjacency_matrix) <- all_node_names

# 真菌、細菌、AMFの自己相関を設定
adjacency_matrix[1:n_fungi_filtered, 1:n_fungi_filtered] <- adjacency_fungi
adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- adjacency_bacteria
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_amf

# グループ間の相関を設定
adjacency_matrix[1:n_fungi_filtered, 
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- adjacency_fungi_bacteria
adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
                 1:n_fungi_filtered] <- t(adjacency_fungi_bacteria)

adjacency_matrix[1:n_fungi_filtered, 
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_fungi_amf
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 1:n_fungi_filtered] <- t(adjacency_fungi_amf)

adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered), 
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_bacteria_amf
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- t(adjacency_bacteria_amf)
diag(adjacency_matrix) <- 0

# igraphオブジェクトを作成
g_canopy_A_total <- graph_from_adjacency_matrix(adjacency_matrix, mode = "undirected")

# 1. 暖色系のカラーパレットを指定,"fungi", "bacteria", "amf" の色を指定
palette_warm <- brewer.pal(3, "Set2")  # "Oranges" を使用（3色）
color_fungi <- palette_warm[1]  # 一番薄い色
color_bacteria <- palette_warm[2]  # 中間の色
color_amf <- palette_warm[3]  # 一番濃い色

# 2. ノードごとに対応する色を割り当て
node_colors <- sapply(V(g_canopy_A_total)$name, function(node_name) {
  if (node_name %in% fungi_names) {
    return(color_fungi)
  } else if (node_name %in% bacteria_names) {
    return(color_bacteria)
  } else if (node_name %in% amf_names) {
    return(color_amf)
  } else {
    return(NA)  # 該当しない場合は NA
  }
})

# 3. ノードの形を設定
node_shapes <- sapply(V(g_canopy_A_total)$name, function(node_name) {
  if (node_name %in% fungi_names) {
    return("square")
  } else if (node_name %in% bacteria_names) {
    return("circle")
  } else if (node_name %in% amf_names) {
    return("csquare")
  } else {
    return(NA)  # 該当しない場合は NA
  }
})

# 4. エッジのないノードを削除
g_canopy_A_total <- delete_vertices(g_canopy_A_total, degree(g_canopy_A_total) == 0)

set.seed(10)

# 5. ノードの設定をプロットに反映
plot(
  g_canopy_A_total,
  vertex.color = adjustcolor(node_colors, alpha.f = 0.7),  # 色を設定
  vertex.shape = node_shapes,  # 形を設定
  vertex.size = log(degree(g_canopy_A_total) + 1) * 3,  # ノードサイズ（例として対数スケーリング）
  edge.width = 2,  # エッジの太さ
  vertex.label = NA  # ラベルは非表示
)

# 6. 凡例を追加
legend("topright", 
       legend = c("Fungi", "Bacteria", "AMF"), 
       fill = adjustcolor(c(color_fungi, color_bacteria, color_amf), alpha.f = 0.7),
       title = "Node Type", 
       border = "black", 
       bty = "n", 
       cex = 1.5, 
       pt.cex = 2)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_ground_class <- taxonomy_fungi_filtered[fungi_names, "Class"]
taxonomy_bacteria_ground_class <- taxonomy_bacteria_filtered[bacteria_names, "Class"]
taxonomy_amf_ground_species <- taxonomy_amf_filtered[amf_names, "Species"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_ground_class)
unique_bacteria_classes <- unique(taxonomy_bacteria_ground_class)
unique_amf_species <- unique(taxonomy_amf_ground_species)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "BuGn"))(length(unique_fungi_classes))  
palette_bacteria <- colorRampPalette(brewer.pal(9, "PuBu"))(length(unique_bacteria_classes)) 
palette_amf <- colorRampPalette(brewer.pal(9, "YlOrRd"))(length(unique_amf_species)) 

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)
species_colors_amf <- setNames(palette_amf, unique_amf_species)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_ground_class]
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_ground_class]
node_colors_amf <- species_colors_amf[taxonomy_amf_ground_species]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_bacteria, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_names))       # 真菌のノードの形
shapes_bacteria <- rep("square", length(bacteria_names))  # バクテリアのノードの形
shapes_amf <- rep("crectangle", length(amf_names))  # amfのノードの形
node_shapes <- c(shapes_fungi, shapes_bacteria, shapes_amf)

# 8. エッジのないノードを削除
g_ground_total <- delete_vertices(g_ground_total, degree(g_ground_total) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_ground_total)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_names) {
    return(class_colors_fungi[taxonomy_fungi_ground_class[match(node_name, fungi_names)]])
  } else if (node_name %in% bacteria_names) {
    return(class_colors_bacteria[taxonomy_bacteria_ground_class[match(node_name, bacteria_names)]])
  } else if (node_name %in% amf_names) {
    return(species_colors_amf[taxonomy_amf_ground_species[match(node_name, amf_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_names))
remaining_node_shapes_bacteria <- rep("square", sum(remaining_node_names %in% bacteria_names))
remaining_node_shapes_amf <- rep("csquare", sum(remaining_node_names %in% amf_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_bacteria, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_ground_total)

# 各ノードの次数を取得
node_degrees <- degree(g_ground_total)

# ノードのサイズを平方根スケーリングで調整
V(g_ground_total)$size <- log(node_degrees + 1) * 2  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_ground_total, 
     layout = layout,
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.5),  # ノードの色と透明度
     vertex.size = V(g_ground_total)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("1209_ground_everything_class&species_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_bacteria_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# AMFの凡例を右下に配置
legend("bottomright", 
       legend = unique_amf_species,  # AMFのカテゴリ名
       fill = adjustcolor(species_colors_amf[unique_amf_species], alpha.f = 0.7),  # AMFの対応する色
       title = "AMF species",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_A_total)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_A_total)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_canopy_everything_A_0.6_ranking.csv", row.names = FALSE)

# 元のデータフレームをコピー
#taxonomy_bacteria_filtered_added <- taxonomy_bacteria_filtered
# 新しい列 "Species" を追加
#taxonomy_bacteria_filtered_added$Species <- NA  # NAで初期化
# タクソノミー情報を結合
#taxonomy_combined <- rbind(taxonomy_fungi_filtered, taxonomy_bacteria_filtered_added, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
#taxonomy_combined_with_asv <- taxonomy_combined %>%
#  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_canopy_everything_A_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

##### Module解析 for 三部グラフ ########
# Louvain法によるモジュール検出（全三部グラフに対して）
tri_partite_clusters <- cluster_louvain(g_canopy_A_total)
# モジュール度（modularity）の計算
modularity_total <- modularity(tri_partite_clusters)
# 結果を表示
cat("三部グラフ全体のモジュール度:", modularity_total, "\n")
# コミュニティごとのメンバーシップを取得
membership_total <- membership(tri_partite_clusters)
# コミュニティに応じたノードの色を割り当て
community_colors <- rainbow(max(membership_total))
node_colors <- community_colors[membership_total]

set.seed(10)

# 三部グラフのプロット（コミュニティごとの色分け）
plot(g_canopy_A_total, 
     layout = layout_with_fr(g_canopy_A_total),  # Fruchterman-Reingoldレイアウト
     vertex.color = node_colors,  # コミュニティごとの色分け
     vertex.size = log(degree(g_canopy_A_total) + 1) * 3 ,  # ノードサイズ
     vertex.shape = node_shapes,  # ノードの形
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
library(bipartite)
library(igraph)

# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
observed_connectance <- networklevel(adjacency_matrix, index = "connectance", weighted = TRUE)
print(observed_connectance)
# 入れ子度（NODF）の計算
observed_nodf <- nested(adjacency_matrix, method = "NODF")
print(observed_nodf)
# 相互作用特殊化度 (H2') の計算
observed_H2_value <- H2fun(adjacency_matrix, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(observed_H2_value)
# 各指標の実行
observed_edge_density <- edge_density(g_canopy_A_total)
observed_edge_count <- ecount(g_canopy_A_total)
observed_global_clustering <- transitivity(g_canopy_A_total, type = "global")
degrees <- degree(g_canopy_A_total)
observed_max_degree <- max(degrees)
observed_mean_degree <- mean(degrees)
observed_num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", observed_edge_density, "\n")
cat("エッジ数:", observed_edge_count, "\n")
cat("グローバルクラスタリング係数:", observed_global_clustering, "\n")
cat("最大degree数:", observed_max_degree, "\n")
cat("平均degree数:", observed_mean_degree, "\n")
cat("エッジ数10以上のノード数:", observed_num_high_degree_nodes, "\n")

#null model

# 指標を格納するためのベクトルを作成
random_connectance <- numeric(100)
random_nodf <- numeric(100)
random_modularity <- numeric(100)
random_h2 <- numeric(100)
random_edge_density <- numeric(100)
random_edge_count <- numeric(100)
random_global_clustering <- numeric(100)
random_max_degree <- numeric(100)
random_mean_degree <- numeric(100)
random_num_high_degree_nodes <- numeric(100)

set.seed(NULL)
for (i in 1:25) {
  # ランダムな三部グラフを生成
  random_graph <- erdos.renyi.game(vcount(g_ground_total), ecount(g_ground_total), type = "gnm")
  
  # ランダムグラフの品質チェック
  if (ecount(random_graph) == 0) next
  
  # 隣接行列を取得
  null_matrix <- as_adjacency_matrix(random_graph, sparse = FALSE)
  
  # 指標を計算
  random_modularity[i] <- modularity(cluster_louvain(random_graph))
  random_connectance[i] <- networklevel(null_matrix, index = "connectance", weighted = TRUE)
  random_nodf[i] <- nested(null_matrix, method = "NODF")
  #random_h2[i] <- H2fun(null_matrix, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
  random_edge_density[i] <- edge_density(random_graph)
  random_global_clustering[i] <- transitivity(random_graph, type = "global")
}

# Null Modelの平均と標準偏差を計算
mean_random_modularity <- mean(random_modularity)
sd_random_modularity <- sd(random_modularity)
mean_random_connectance <- mean(random_connectance)
sd_random_connectance <- sd(random_connectance)
mean_random_nodf <- mean(random_nodf)
sd_random_nodf <- sd(random_nodf)
mean_random_edge_density <- mean(random_edge_density)
sd_random_edge_density <- sd(random_edge_density)
mean_random_global_clustering <- mean(random_global_clustering)
sd_random_global_clustering <- sd(random_global_clustering)

# zスコアを計算
if (sd_random_modularity == 0) {
  z_modularity <- NA
} else {
  z_modularity <- (observed_modularity - mean_random_modularity) / sd_random_modularity
}
if (sd_random_connectance == 0) {
  z_connectance <- NA
} else {
  z_connectance <- (observed_connectance - mean_random_connectance) / sd_random_connectance
}
if (sd_random_nodf == 0) {
  z_nodf <- NA
} else {
  z_nodf <- (observed_nodf - mean_random_nodf) / sd_random_nodf
}
if (sd_random_edge_density == 0) {
  z_edge_density <- NA
} else {
  z_edge_density <- (observed_edge_density - mean_random_edge_density) / sd_random_edge_density
}
if (sd_random_global_clustering == 0) {
  z_connectance <- NA
} else {
  z_clustering <- (observed_clustering - mean_random_global_clustering) / sd_random_global_clustering
}

# p値を計算（片側検定）
p_modularity <- 2 * (1 - pnorm(abs(z_modularity)))
p_connectance <- 2 * (1 - pnorm(abs(z_connectance)))
p_nodf <- 2 * (1 - pnorm(abs(z_nodf)))
p_edge_density <- 2 * (1 - pnorm(abs(z_edge_density)))
p_clustering <- 2 * (1 - pnorm(abs(z_clustering)))

# 結果を表示
cat("モジュール度: zスコア =", z_modularity, ", p値 =", p_modularity, "\n")
cat("モジュール度: zスコア =", z_connectance, ", p値 =", p_connectance, "\n")
cat("モジュール度: zスコア =", z_nodf, ", p値 =", p_nodf, "\n")
cat("エッジ密度: zスコア =", z_edge_density, ", p値 =", p_edge_density, "\n")
cat("クラスタリング係数: zスコア =", z_clustering, ", p値 =", p_clustering, "\n")
#### TWINASPAN B F*B ################################################################################
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_canopy_everything_table_filtered_B) %in% colnames(asv_fungi_canopy))
n_bacteria_filtered <- sum(colnames(combined_canopy_everything_table_filtered_B) %in% colnames(asv_bacteria_canopy))
n_amf_filtered <- sum(colnames(combined_canopy_everything_table_filtered_B) %in% colnames(asv_amf_canopy))

# 相関行列を分割
fungi_corr <- correlation_canopy_everything_B_matrix[1:n_fungi_filtered, 1:n_fungi_filtered]
bacteria_corr <- correlation_canopy_everything_B_matrix[
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)
]
amf_corr <- correlation_canopy_everything_B_matrix[
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered),
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]

fungi_bacteria_corr <- correlation_canopy_everything_B_matrix[1:n_fungi_filtered,
                                                              (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)
]
fungi_amf_corr <- correlation_canopy_everything_B_matrix[1:n_fungi_filtered,
                                                         (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]
bacteria_amf_corr <- correlation_canopy_everything_B_matrix[
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]

# 隣接行列の作成（相関係数が0.6以上の場合に1を設定）
adjacency_fungi <- ifelse(fungi_corr >= 0.6, 1, 0)
adjacency_bacteria <- ifelse(bacteria_corr >= 0.6, 1, 0)
adjacency_amf <- ifelse(amf_corr >= 0.6, 1, 0)

adjacency_fungi_bacteria <- ifelse(fungi_bacteria_corr >= 0.6, 1, 0)
adjacency_fungi_amf <- ifelse(fungi_amf_corr >= 0.6, 1, 0)
adjacency_bacteria_amf <- ifelse(bacteria_amf_corr >= 0.6, 1, 0)

# 全体の隣接行列を構築
total_nodes <- n_fungi_filtered + n_bacteria_filtered + n_amf_filtered
adjacency_matrix <- matrix(0, nrow = total_nodes, ncol = total_nodes)
# 全ノードの名前を作成
fungi_names <- colnames(combined_canopy_everything_table_filtered_B)[colnames(combined_canopy_everything_table_filtered_B) %in% colnames(asv_fungi_canopy)]
bacteria_names <- colnames(combined_canopy_everything_table_filtered_B)[colnames(combined_canopy_everything_table_filtered_B) %in% colnames(asv_bacteria_canopy)]
amf_names <- colnames(combined_canopy_everything_table_filtered_B)[colnames(combined_canopy_everything_table_filtered_B) %in% colnames(asv_amf_canopy)]
# 名前を結合して全体のノード名を作成
all_node_names <- c(fungi_names, bacteria_names, amf_names)
# adjacency_matrix に行名と列名を追加
rownames(adjacency_matrix) <- all_node_names
colnames(adjacency_matrix) <- all_node_names

# 真菌、細菌、AMFの自己相関を設定
adjacency_matrix[1:n_fungi_filtered, 1:n_fungi_filtered] <- adjacency_fungi
adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- adjacency_bacteria
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_amf

# グループ間の相関を設定
adjacency_matrix[1:n_fungi_filtered, 
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- adjacency_fungi_bacteria
adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
                 1:n_fungi_filtered] <- t(adjacency_fungi_bacteria)

adjacency_matrix[1:n_fungi_filtered, 
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_fungi_amf
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 1:n_fungi_filtered] <- t(adjacency_fungi_amf)

adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered), 
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_bacteria_amf
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- t(adjacency_bacteria_amf)
diag(adjacency_matrix) <- 0

# igraphオブジェクトを作成
g_canopy_B_total <- graph_from_adjacency_matrix(adjacency_matrix, mode = "undirected")

# 1. 暖色系のカラーパレットを指定,"fungi", "bacteria", "amf" の色を指定
palette_warm <- brewer.pal(3, "Set2")  # "Oranges" を使用（3色）
color_fungi <- palette_warm[1]  # 一番薄い色
color_bacteria <- palette_warm[2]  # 中間の色
color_amf <- palette_warm[3]  # 一番濃い色

# 2. ノードごとに対応する色を割り当て
node_colors <- sapply(V(g_canopy_B_total)$name, function(node_name) {
  if (node_name %in% fungi_names) {
    return(color_fungi)
  } else if (node_name %in% bacteria_names) {
    return(color_bacteria)
  } else if (node_name %in% amf_names) {
    return(color_amf)
  } else {
    return(NA)  # 該当しない場合は NA
  }
})

# 3. ノードの形を設定
node_shapes <- sapply(V(g_canopy_B_total)$name, function(node_name) {
  if (node_name %in% fungi_names) {
    return("square")
  } else if (node_name %in% bacteria_names) {
    return("circle")
  } else if (node_name %in% amf_names) {
    return("csquare")
  } else {
    return(NA)  # 該当しない場合は NA
  }
})

# 4. エッジのないノードを削除
g_canopy_B_total <- delete_vertices(g_canopy_B_total, degree(g_canopy_B_total) == 0)

set.seed(10)

# 5. ノードの設定をプロットに反映
plot(
  g_canopy_B_total,
  vertex.color = adjustcolor(node_colors, alpha.f = 0.7),  # 色を設定
  vertex.shape = node_shapes,  # 形を設定
  vertex.size = log(degree(g_canopy_B_total) + 1) * 3,  # ノードサイズ（例として対数スケーリング）
  edge.width = 2,  # エッジの太さ
  vertex.label = NA  # ラベルは非表示
)

# 6. 凡例を追加
legend("topright", 
       legend = c("Fungi", "Bacteria", "AMF"), 
       fill = adjustcolor(c(color_fungi, color_bacteria, color_amf), alpha.f = 0.7),
       title = "Node Type", 
       border = "black", 
       bty = "n", 
       cex = 1.5, 
       pt.cex = 2)


# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_ground_class <- taxonomy_fungi_filtered[fungi_names, "Class"]
taxonomy_bacteria_ground_class <- taxonomy_bacteria_filtered[bacteria_names, "Class"]
taxonomy_amf_ground_species <- taxonomy_amf_filtered[amf_names, "Species"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_ground_class)
unique_bacteria_classes <- unique(taxonomy_bacteria_ground_class)
unique_amf_species <- unique(taxonomy_amf_ground_species)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "BuGn"))(length(unique_fungi_classes))  
palette_bacteria <- colorRampPalette(brewer.pal(9, "PuBu"))(length(unique_bacteria_classes)) 
palette_amf <- colorRampPalette(brewer.pal(9, "YlOrRd"))(length(unique_amf_species)) 

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)
species_colors_amf <- setNames(palette_amf, unique_amf_species)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_ground_class]
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_ground_class]
node_colors_amf <- species_colors_amf[taxonomy_amf_ground_species]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_bacteria, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_names))       # 真菌のノードの形
shapes_bacteria <- rep("square", length(bacteria_names))  # バクテリアのノードの形
shapes_amf <- rep("crectangle", length(amf_names))  # amfのノードの形
node_shapes <- c(shapes_fungi, shapes_bacteria, shapes_amf)

# 8. エッジのないノードを削除
g_ground_total <- delete_vertices(g_ground_total, degree(g_ground_total) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_ground_total)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_names) {
    return(class_colors_fungi[taxonomy_fungi_ground_class[match(node_name, fungi_names)]])
  } else if (node_name %in% bacteria_names) {
    return(class_colors_bacteria[taxonomy_bacteria_ground_class[match(node_name, bacteria_names)]])
  } else if (node_name %in% amf_names) {
    return(species_colors_amf[taxonomy_amf_ground_species[match(node_name, amf_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_names))
remaining_node_shapes_bacteria <- rep("square", sum(remaining_node_names %in% bacteria_names))
remaining_node_shapes_amf <- rep("csquare", sum(remaining_node_names %in% amf_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_bacteria, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_ground_total)

# 各ノードの次数を取得
node_degrees <- degree(g_ground_total)

# ノードのサイズを平方根スケーリングで調整
V(g_ground_total)$size <- log(node_degrees + 1) * 2  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_ground_total, 
     layout = layout,
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.5),  # ノードの色と透明度
     vertex.size = V(g_ground_total)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("1209_ground_everything_class&species_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_bacteria_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# AMFの凡例を右下に配置
legend("bottomright", 
       legend = unique_amf_species,  # AMFのカテゴリ名
       fill = adjustcolor(species_colors_amf[unique_amf_species], alpha.f = 0.7),  # AMFの対応する色
       title = "AMF species",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_B_total)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_B_total)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_canopy_everything_B_0.6_ranking.csv", row.names = FALSE)

# 元のデータフレームをコピー
#taxonomy_bacteria_filtered_added <- taxonomy_bacteria_filtered
# 新しい列 "Species" を追加
#taxonomy_bacteria_filtered_added$Species <- NA  # NAで初期化
# タクソノミー情報を結合
#taxonomy_combined <- rbind(taxonomy_fungi_filtered, taxonomy_bacteria_filtered_added, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
#taxonomy_combined_with_asv <- taxonomy_combined %>%
#  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_canopy_everything_B_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

##### Module解析 for 三部グラフ ########
# Louvain法によるモジュール検出（全三部グラフに対して）
tri_partite_clusters <- cluster_louvain(g_canopy_B_total)
# モジュール度（modularity）の計算
modularity_total <- modularity(tri_partite_clusters)
# 結果を表示
cat("三部グラフ全体のモジュール度:", modularity_total, "\n")
# コミュニティごとのメンバーシップを取得
membership_total <- membership(tri_partite_clusters)
# コミュニティに応じたノードの色を割り当て
community_colors <- rainbow(max(membership_total))
node_colors <- community_colors[membership_total]

set.seed(10)

# 三部グラフのプロット（コミュニティごとの色分け）
plot(g_canopy_B_total, 
     layout = layout_with_fr(g_canopy_B_total),  # Fruchterman-Reingoldレイアウト
     vertex.color = node_colors,  # コミュニティごとの色分け
     vertex.size = log(degree(g_canopy_B_total) + 1) * 3 ,  # ノードサイズ
     vertex.shape = node_shapes,  # ノードの形
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
library(bipartite)
library(igraph)

# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
observed_connectance <- networklevel(adjacency_matrix, index = "connectance", weighted = TRUE)
print(observed_connectance)
# 入れ子度（NODF）の計算
observed_nodf <- nested(adjacency_matrix, method = "NODF")
print(observed_nodf)
# 相互作用特殊化度 (H2') の計算
observed_H2_value <- H2fun(adjacency_matrix, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(observed_H2_value)
# 各指標の実行
observed_edge_density <- edge_density(g_canopy_B_total)
observed_edge_count <- ecount(g_canopy_B_total)
observed_global_clustering <- transitivity(g_canopy_B_total, type = "global")
degrees <- degree(g_canopy_B_total)
observed_max_degree <- max(degrees)
observed_mean_degree <- mean(degrees)
observed_num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", observed_edge_density, "\n")
cat("エッジ数:", observed_edge_count, "\n")
cat("グローバルクラスタリング係数:", observed_global_clustering, "\n")
cat("最大degree数:", observed_max_degree, "\n")
cat("平均degree数:", observed_mean_degree, "\n")
cat("エッジ数10以上のノード数:", observed_num_high_degree_nodes, "\n")

#null model

# 指標を格納するためのベクトルを作成
random_connectance <- numeric(100)
random_nodf <- numeric(100)
random_modularity <- numeric(100)
random_h2 <- numeric(100)
random_edge_density <- numeric(100)
random_edge_count <- numeric(100)
random_global_clustering <- numeric(100)
random_max_degree <- numeric(100)
random_mean_degree <- numeric(100)
random_num_high_degree_nodes <- numeric(100)

set.seed(NULL)
for (i in 1:25) {
  # ランダムな三部グラフを生成
  random_graph <- erdos.renyi.game(vcount(g_ground_total), ecount(g_ground_total), type = "gnm")
  
  # ランダムグラフの品質チェック
  if (ecount(random_graph) == 0) next
  
  # 隣接行列を取得
  null_matrix <- as_adjacency_matrix(random_graph, sparse = FALSE)
  
  # 指標を計算
  random_modularity[i] <- modularity(cluster_louvain(random_graph))
  random_connectance[i] <- networklevel(null_matrix, index = "connectance", weighted = TRUE)
  random_nodf[i] <- nested(null_matrix, method = "NODF")
  #random_h2[i] <- H2fun(null_matrix, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
  random_edge_density[i] <- edge_density(random_graph)
  random_global_clustering[i] <- transitivity(random_graph, type = "global")
}

# Null Modelの平均と標準偏差を計算
mean_random_modularity <- mean(random_modularity)
sd_random_modularity <- sd(random_modularity)
mean_random_connectance <- mean(random_connectance)
sd_random_connectance <- sd(random_connectance)
mean_random_nodf <- mean(random_nodf)
sd_random_nodf <- sd(random_nodf)
mean_random_edge_density <- mean(random_edge_density)
sd_random_edge_density <- sd(random_edge_density)
mean_random_global_clustering <- mean(random_global_clustering)
sd_random_global_clustering <- sd(random_global_clustering)

# zスコアを計算
if (sd_random_modularity == 0) {
  z_modularity <- NA
} else {
  z_modularity <- (observed_modularity - mean_random_modularity) / sd_random_modularity
}
if (sd_random_connectance == 0) {
  z_connectance <- NA
} else {
  z_connectance <- (observed_connectance - mean_random_connectance) / sd_random_connectance
}
if (sd_random_nodf == 0) {
  z_nodf <- NA
} else {
  z_nodf <- (observed_nodf - mean_random_nodf) / sd_random_nodf
}
if (sd_random_edge_density == 0) {
  z_edge_density <- NA
} else {
  z_edge_density <- (observed_edge_density - mean_random_edge_density) / sd_random_edge_density
}
if (sd_random_global_clustering == 0) {
  z_connectance <- NA
} else {
  z_clustering <- (observed_clustering - mean_random_global_clustering) / sd_random_global_clustering
}

# p値を計算（片側検定）
p_modularity <- 2 * (1 - pnorm(abs(z_modularity)))
p_connectance <- 2 * (1 - pnorm(abs(z_connectance)))
p_nodf <- 2 * (1 - pnorm(abs(z_nodf)))
p_edge_density <- 2 * (1 - pnorm(abs(z_edge_density)))
p_clustering <- 2 * (1 - pnorm(abs(z_clustering)))

# 結果を表示
cat("モジュール度: zスコア =", z_modularity, ", p値 =", p_modularity, "\n")
cat("モジュール度: zスコア =", z_connectance, ", p値 =", p_connectance, "\n")
cat("モジュール度: zスコア =", z_nodf, ", p値 =", p_nodf, "\n")
cat("エッジ密度: zスコア =", z_edge_density, ", p値 =", p_edge_density, "\n")
cat("クラスタリング係数: zスコア =", z_clustering, ", p値 =", p_clustering, "\n")
#### TWINASPAN C F*B ################################################################################
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_canopy_everything_table_filtered_C) %in% colnames(asv_fungi_canopy))
n_bacteria_filtered <- sum(colnames(combined_canopy_everything_table_filtered_C) %in% colnames(asv_bacteria_canopy))
n_amf_filtered <- sum(colnames(combined_canopy_everything_table_filtered_C) %in% colnames(asv_amf_canopy))

# 相関行列を分割
fungi_corr <- correlation_canopy_everything_C_matrix[1:n_fungi_filtered, 1:n_fungi_filtered]
bacteria_corr <- correlation_canopy_everything_C_matrix[
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)
]
amf_corr <- correlation_canopy_everything_C_matrix[
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered),
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]

fungi_bacteria_corr <- correlation_canopy_everything_C_matrix[1:n_fungi_filtered,
                                                              (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)
]
fungi_amf_corr <- correlation_canopy_everything_C_matrix[1:n_fungi_filtered,
                                                         (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]
bacteria_amf_corr <- correlation_canopy_everything_C_matrix[
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]

# 隣接行列の作成（相関係数が0.6以上の場合に1を設定）
adjacency_fungi <- ifelse(fungi_corr >= 0.6, 1, 0)
adjacency_bacteria <- ifelse(bacteria_corr >= 0.6, 1, 0)
adjacency_amf <- ifelse(amf_corr >= 0.6, 1, 0)

adjacency_fungi_bacteria <- ifelse(fungi_bacteria_corr >= 0.6, 1, 0)
adjacency_fungi_amf <- ifelse(fungi_amf_corr >= 0.6, 1, 0)
adjacency_bacteria_amf <- ifelse(bacteria_amf_corr >= 0.6, 1, 0)

# 全体の隣接行列を構築
total_nodes <- n_fungi_filtered + n_bacteria_filtered + n_amf_filtered
adjacency_matrix <- matrix(0, nrow = total_nodes, ncol = total_nodes)
# 全ノードの名前を作成
fungi_names <- colnames(combined_canopy_everything_table_filtered_C)[colnames(combined_canopy_everything_table_filtered_C) %in% colnames(asv_fungi_canopy)]
bacteria_names <- colnames(combined_canopy_everything_table_filtered_C)[colnames(combined_canopy_everything_table_filtered_C) %in% colnames(asv_bacteria_canopy)]
amf_names <- colnames(combined_canopy_everything_table_filtered_C)[colnames(combined_canopy_everything_table_filtered_C) %in% colnames(asv_amf_canopy)]
# 名前を結合して全体のノード名を作成
all_node_names <- c(fungi_names, bacteria_names, amf_names)
# adjacency_matrix に行名と列名を追加
rownames(adjacency_matrix) <- all_node_names
colnames(adjacency_matrix) <- all_node_names

# 真菌、細菌、AMFの自己相関を設定
adjacency_matrix[1:n_fungi_filtered, 1:n_fungi_filtered] <- adjacency_fungi
adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- adjacency_bacteria
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_amf

# グループ間の相関を設定
adjacency_matrix[1:n_fungi_filtered, 
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- adjacency_fungi_bacteria
adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
                 1:n_fungi_filtered] <- t(adjacency_fungi_bacteria)

adjacency_matrix[1:n_fungi_filtered, 
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_fungi_amf
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 1:n_fungi_filtered] <- t(adjacency_fungi_amf)

adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered), 
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_bacteria_amf
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- t(adjacency_bacteria_amf)
diag(adjacency_matrix) <- 0

# igraphオブジェクトを作成
g_canopy_C_total <- graph_from_adjacency_matrix(adjacency_matrix, mode = "undirected")

# 1. 暖色系のカラーパレットを指定,"fungi", "bacteria", "amf" の色を指定
palette_warm <- brewer.pal(3, "Set2")  # "Oranges" を使用（3色）
color_fungi <- palette_warm[1]  # 一番薄い色
color_bacteria <- palette_warm[2]  # 中間の色
color_amf <- palette_warm[3]  # 一番濃い色

# 2. ノードごとに対応する色を割り当て
node_colors <- sapply(V(g_canopy_C_total)$name, function(node_name) {
  if (node_name %in% fungi_names) {
    return(color_fungi)
  } else if (node_name %in% bacteria_names) {
    return(color_bacteria)
  } else if (node_name %in% amf_names) {
    return(color_amf)
  } else {
    return(NA)  # 該当しない場合は NA
  }
})

# 3. ノードの形を設定
node_shapes <- sapply(V(g_canopy_C_total)$name, function(node_name) {
  if (node_name %in% fungi_names) {
    return("square")
  } else if (node_name %in% bacteria_names) {
    return("circle")
  } else if (node_name %in% amf_names) {
    return("csquare")
  } else {
    return(NA)  # 該当しない場合は NA
  }
})

# 4. エッジのないノードを削除
g_canopy_C_total <- delete_vertices(g_canopy_C_total, degree(g_canopy_C_total) == 0)

set.seed(10)

# 5. ノードの設定をプロットに反映
plot(
  g_canopy_C_total,
  vertex.color = adjustcolor(node_colors, alpha.f = 0.7),  # 色を設定
  vertex.shape = node_shapes,  # 形を設定
  vertex.size = log(degree(g_canopy_C_total) + 1) * 3,  # ノードサイズ（例として対数スケーリング）
  edge.width = 2,  # エッジの太さ
  vertex.label = NA  # ラベルは非表示
)

# 6. 凡例を追加
legend("topright", 
       legend = c("Fungi", "Bacteria", "AMF"), 
       fill = adjustcolor(c(color_fungi, color_bacteria, color_amf), alpha.f = 0.7),
       title = "Node Type", 
       border = "black", 
       bty = "n", 
       cex = 1.5, 
       pt.cex = 2)


# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_ground_class <- taxonomy_fungi_filtered[fungi_names, "Class"]
taxonomy_bacteria_ground_class <- taxonomy_bacteria_filtered[bacteria_names, "Class"]
taxonomy_amf_ground_species <- taxonomy_amf_filtered[amf_names, "Species"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_ground_class)
unique_bacteria_classes <- unique(taxonomy_bacteria_ground_class)
unique_amf_species <- unique(taxonomy_amf_ground_species)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "BuGn"))(length(unique_fungi_classes))  
palette_bacteria <- colorRampPalette(brewer.pal(9, "PuBu"))(length(unique_bacteria_classes)) 
palette_amf <- colorRampPalette(brewer.pal(9, "YlOrRd"))(length(unique_amf_species)) 

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)
species_colors_amf <- setNames(palette_amf, unique_amf_species)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_ground_class]
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_ground_class]
node_colors_amf <- species_colors_amf[taxonomy_amf_ground_species]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_bacteria, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_names))       # 真菌のノードの形
shapes_bacteria <- rep("square", length(bacteria_names))  # バクテリアのノードの形
shapes_amf <- rep("crectangle", length(amf_names))  # amfのノードの形
node_shapes <- c(shapes_fungi, shapes_bacteria, shapes_amf)

# 8. エッジのないノードを削除
g_ground_total <- delete_vertices(g_ground_total, degree(g_ground_total) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_ground_total)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_names) {
    return(class_colors_fungi[taxonomy_fungi_ground_class[match(node_name, fungi_names)]])
  } else if (node_name %in% bacteria_names) {
    return(class_colors_bacteria[taxonomy_bacteria_ground_class[match(node_name, bacteria_names)]])
  } else if (node_name %in% amf_names) {
    return(species_colors_amf[taxonomy_amf_ground_species[match(node_name, amf_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_names))
remaining_node_shapes_bacteria <- rep("square", sum(remaining_node_names %in% bacteria_names))
remaining_node_shapes_amf <- rep("csquare", sum(remaining_node_names %in% amf_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_bacteria, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_ground_total)

# 各ノードの次数を取得
node_degrees <- degree(g_ground_total)

# ノードのサイズを平方根スケーリングで調整
V(g_ground_total)$size <- log(node_degrees + 1) * 2  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_ground_total, 
     layout = layout,
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.5),  # ノードの色と透明度
     vertex.size = V(g_ground_total)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("1209_ground_everything_class&species_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_bacteria_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# AMFの凡例を右下に配置
legend("bottomright", 
       legend = unique_amf_species,  # AMFのカテゴリ名
       fill = adjustcolor(species_colors_amf[unique_amf_species], alpha.f = 0.7),  # AMFの対応する色
       title = "AMF species",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_C_total)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_C_total)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_canopy_everything_C_0.6_ranking.csv", row.names = FALSE)

# 元のデータフレームをコピー
#taxonomy_bacteria_filtered_added <- taxonomy_bacteria_filtered
# 新しい列 "Species" を追加
#taxonomy_bacteria_filtered_added$Species <- NA  # NAで初期化
# タクソノミー情報を結合
#taxonomy_combined <- rbind(taxonomy_fungi_filtered, taxonomy_bacteria_filtered_added, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
#taxonomy_combined_with_asv <- taxonomy_combined %>%
#  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_canopy_everything_C_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

##### Module解析 for 三部グラフ ########
# Louvain法によるモジュール検出（全三部グラフに対して）
tri_partite_clusters <- cluster_louvain(g_canopy_C_total)
# モジュール度（modularity）の計算
modularity_total <- modularity(tri_partite_clusters)
# 結果を表示
cat("三部グラフ全体のモジュール度:", modularity_total, "\n")
# コミュニティごとのメンバーシップを取得
membership_total <- membership(tri_partite_clusters)
# コミュニティに応じたノードの色を割り当て
community_colors <- rainbow(max(membership_total))
node_colors <- community_colors[membership_total]

set.seed(10)

# 三部グラフのプロット（コミュニティごとの色分け）
plot(g_canopy_C_total, 
     layout = layout_with_fr(g_canopy_C_total),  # Fruchterman-Reingoldレイアウト
     vertex.color = node_colors,  # コミュニティごとの色分け
     vertex.size = log(degree(g_canopy_C_total) + 1) * 3 ,  # ノードサイズ
     vertex.shape = node_shapes,  # ノードの形
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
library(bipartite)
library(igraph)

# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
observed_connectance <- networklevel(adjacency_matrix, index = "connectance", weighted = TRUE)
print(observed_connectance)
# 入れ子度（NODF）の計算
observed_nodf <- nested(adjacency_matrix, method = "NODF")
print(observed_nodf)
# 相互作用特殊化度 (H2') の計算
observed_H2_value <- H2fun(adjacency_matrix, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(observed_H2_value)
# 各指標の実行
observed_edge_density <- edge_density(g_canopy_C_total)
observed_edge_count <- ecount(g_canopy_C_total)
observed_global_clustering <- transitivity(g_canopy_C_total, type = "global")
degrees <- degree(g_canopy_C_total)
observed_max_degree <- max(degrees)
observed_mean_degree <- mean(degrees)
observed_num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", observed_edge_density, "\n")
cat("エッジ数:", observed_edge_count, "\n")
cat("グローバルクラスタリング係数:", observed_global_clustering, "\n")
cat("最大degree数:", observed_max_degree, "\n")
cat("平均degree数:", observed_mean_degree, "\n")
cat("エッジ数10以上のノード数:", observed_num_high_degree_nodes, "\n")

#null model

# 指標を格納するためのベクトルを作成
random_connectance <- numeric(100)
random_nodf <- numeric(100)
random_modularity <- numeric(100)
random_h2 <- numeric(100)
random_edge_density <- numeric(100)
random_edge_count <- numeric(100)
random_global_clustering <- numeric(100)
random_max_degree <- numeric(100)
random_mean_degree <- numeric(100)
random_num_high_degree_nodes <- numeric(100)

set.seed(NULL)
for (i in 1:25) {
  # ランダムな三部グラフを生成
  random_graph <- erdos.renyi.game(vcount(g_ground_total), ecount(g_ground_total), type = "gnm")
  
  # ランダムグラフの品質チェック
  if (ecount(random_graph) == 0) next
  
  # 隣接行列を取得
  null_matrix <- as_adjacency_matrix(random_graph, sparse = FALSE)
  
  # 指標を計算
  random_modularity[i] <- modularity(cluster_louvain(random_graph))
  random_connectance[i] <- networklevel(null_matrix, index = "connectance", weighted = TRUE)
  random_nodf[i] <- nested(null_matrix, method = "NODF")
  #random_h2[i] <- H2fun(null_matrix, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
  random_edge_density[i] <- edge_density(random_graph)
  random_global_clustering[i] <- transitivity(random_graph, type = "global")
}

# Null Modelの平均と標準偏差を計算
mean_random_modularity <- mean(random_modularity)
sd_random_modularity <- sd(random_modularity)
mean_random_connectance <- mean(random_connectance)
sd_random_connectance <- sd(random_connectance)
mean_random_nodf <- mean(random_nodf)
sd_random_nodf <- sd(random_nodf)
mean_random_edge_density <- mean(random_edge_density)
sd_random_edge_density <- sd(random_edge_density)
mean_random_global_clustering <- mean(random_global_clustering)
sd_random_global_clustering <- sd(random_global_clustering)

# zスコアを計算
if (sd_random_modularity == 0) {
  z_modularity <- NA
} else {
  z_modularity <- (observed_modularity - mean_random_modularity) / sd_random_modularity
}
if (sd_random_connectance == 0) {
  z_connectance <- NA
} else {
  z_connectance <- (observed_connectance - mean_random_connectance) / sd_random_connectance
}
if (sd_random_nodf == 0) {
  z_nodf <- NA
} else {
  z_nodf <- (observed_nodf - mean_random_nodf) / sd_random_nodf
}
if (sd_random_edge_density == 0) {
  z_edge_density <- NA
} else {
  z_edge_density <- (observed_edge_density - mean_random_edge_density) / sd_random_edge_density
}
if (sd_random_global_clustering == 0) {
  z_connectance <- NA
} else {
  z_clustering <- (observed_clustering - mean_random_global_clustering) / sd_random_global_clustering
}

# p値を計算（片側検定）
p_modularity <- 2 * (1 - pnorm(abs(z_modularity)))
p_connectance <- 2 * (1 - pnorm(abs(z_connectance)))
p_nodf <- 2 * (1 - pnorm(abs(z_nodf)))
p_edge_density <- 2 * (1 - pnorm(abs(z_edge_density)))
p_clustering <- 2 * (1 - pnorm(abs(z_clustering)))

# 結果を表示
cat("モジュール度: zスコア =", z_modularity, ", p値 =", p_modularity, "\n")
cat("モジュール度: zスコア =", z_connectance, ", p値 =", p_connectance, "\n")
cat("モジュール度: zスコア =", z_nodf, ", p値 =", p_nodf, "\n")
cat("エッジ密度: zスコア =", z_edge_density, ", p値 =", p_edge_density, "\n")
cat("クラスタリング係数: zスコア =", z_clustering, ", p値 =", p_clustering, "\n")
#### TWINASPAN D F*B ################################################################################
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_canopy_everything_table_filtered_D) %in% colnames(asv_fungi_canopy))
n_bacteria_filtered <- sum(colnames(combined_canopy_everything_table_filtered_D) %in% colnames(asv_bacteria_canopy))
n_amf_filtered <- sum(colnames(combined_canopy_everything_table_filtered_D) %in% colnames(asv_amf_canopy))

# 相関行列を分割
fungi_corr <- correlation_canopy_everything_D_matrix[1:n_fungi_filtered, 1:n_fungi_filtered]
bacteria_corr <- correlation_canopy_everything_D_matrix[
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)
]
amf_corr <- correlation_canopy_everything_D_matrix[
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered),
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]

fungi_bacteria_corr <- correlation_canopy_everything_D_matrix[1:n_fungi_filtered,
                                                              (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)
]
fungi_amf_corr <- correlation_canopy_everything_D_matrix[1:n_fungi_filtered,
                                                         (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]
bacteria_amf_corr <- correlation_canopy_everything_D_matrix[
  (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
  (n_fungi_filtered+n_bacteria_filtered+1):(n_fungi_filtered+n_bacteria_filtered+n_amf_filtered)
]

# 隣接行列の作成（相関係数が0.6以上の場合に1を設定）
adjacency_fungi <- ifelse(fungi_corr >= 0.6, 1, 0)
adjacency_bacteria <- ifelse(bacteria_corr >= 0.6, 1, 0)
adjacency_amf <- ifelse(amf_corr >= 0.6, 1, 0)

adjacency_fungi_bacteria <- ifelse(fungi_bacteria_corr >= 0.6, 1, 0)
adjacency_fungi_amf <- ifelse(fungi_amf_corr >= 0.6, 1, 0)
adjacency_bacteria_amf <- ifelse(bacteria_amf_corr >= 0.6, 1, 0)

# 全体の隣接行列を構築
total_nodes <- n_fungi_filtered + n_bacteria_filtered + n_amf_filtered
adjacency_matrix <- matrix(0, nrow = total_nodes, ncol = total_nodes)
# 全ノードの名前を作成
fungi_names <- colnames(combined_canopy_everything_table_filtered_D)[colnames(combined_canopy_everything_table_filtered_D) %in% colnames(asv_fungi_canopy)]
bacteria_names <- colnames(combined_canopy_everything_table_filtered_D)[colnames(combined_canopy_everything_table_filtered_D) %in% colnames(asv_bacteria_canopy)]
amf_names <- colnames(combined_canopy_everything_table_filtered_D)[colnames(combined_canopy_everything_table_filtered_D) %in% colnames(asv_amf_canopy)]
# 名前を結合して全体のノード名を作成
all_node_names <- c(fungi_names, bacteria_names, amf_names)
# adjacency_matrix に行名と列名を追加
rownames(adjacency_matrix) <- all_node_names
colnames(adjacency_matrix) <- all_node_names

# 真菌、細菌、AMFの自己相関を設定
adjacency_matrix[1:n_fungi_filtered, 1:n_fungi_filtered] <- adjacency_fungi
adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- adjacency_bacteria
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_amf

# グループ間の相関を設定
adjacency_matrix[1:n_fungi_filtered, 
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- adjacency_fungi_bacteria
adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered),
                 1:n_fungi_filtered] <- t(adjacency_fungi_bacteria)

adjacency_matrix[1:n_fungi_filtered, 
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_fungi_amf
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 1:n_fungi_filtered] <- t(adjacency_fungi_amf)

adjacency_matrix[(n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered), 
                 (n_fungi_filtered+n_bacteria_filtered+1):total_nodes] <- adjacency_bacteria_amf
adjacency_matrix[(n_fungi_filtered+n_bacteria_filtered+1):total_nodes,
                 (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)] <- t(adjacency_bacteria_amf)
diag(adjacency_matrix) <- 0

# igraphオブジェクトを作成
g_canopy_D_total <- graph_from_adjacency_matrix(adjacency_matrix, mode = "undirected")

# 1. 暖色系のカラーパレットを指定,"fungi", "bacteria", "amf" の色を指定
palette_warm <- brewer.pal(3, "Set2")  # "Oranges" を使用（3色）
color_fungi <- palette_warm[1]  # 一番薄い色
color_bacteria <- palette_warm[2]  # 中間の色
color_amf <- palette_warm[3]  # 一番濃い色

# 2. ノードごとに対応する色を割り当て
node_colors <- sapply(V(g_canopy_D_total)$name, function(node_name) {
  if (node_name %in% fungi_names) {
    return(color_fungi)
  } else if (node_name %in% bacteria_names) {
    return(color_bacteria)
  } else if (node_name %in% amf_names) {
    return(color_amf)
  } else {
    return(NA)  # 該当しない場合は NA
  }
})

# 3. ノードの形を設定
node_shapes <- sapply(V(g_canopy_D_total)$name, function(node_name) {
  if (node_name %in% fungi_names) {
    return("square")
  } else if (node_name %in% bacteria_names) {
    return("circle")
  } else if (node_name %in% amf_names) {
    return("csquare")
  } else {
    return(NA)  # 該当しない場合は NA
  }
})

# 4. エッジのないノードを削除
g_canopy_D_total <- delete_vertices(g_canopy_D_total, degree(g_canopy_D_total) == 0)

set.seed(10)

# 5. ノードの設定をプロットに反映
plot(
  g_canopy_D_total,
  vertex.color = adjustcolor(node_colors, alpha.f = 0.7),  # 色を設定
  vertex.shape = node_shapes,  # 形を設定
  vertex.size = log(degree(g_canopy_D_total) + 1) * 3,  # ノードサイズ（例として対数スケーリング）
  edge.width = 2,  # エッジの太さ
  vertex.label = NA  # ラベルは非表示
)

# 6. 凡例を追加
legend("topright", 
       legend = c("Fungi", "Bacteria", "AMF"), 
       fill = adjustcolor(c(color_fungi, color_bacteria, color_amf), alpha.f = 0.7),
       title = "Node Type", 
       border = "black", 
       bty = "n", 
       cex = 1.5, 
       pt.cex = 2)


# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_ground_class <- taxonomy_fungi_filtered[fungi_names, "Class"]
taxonomy_bacteria_ground_class <- taxonomy_bacteria_filtered[bacteria_names, "Class"]
taxonomy_amf_ground_species <- taxonomy_amf_filtered[amf_names, "Species"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_ground_class)
unique_bacteria_classes <- unique(taxonomy_bacteria_ground_class)
unique_amf_species <- unique(taxonomy_amf_ground_species)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "BuGn"))(length(unique_fungi_classes))  
palette_bacteria <- colorRampPalette(brewer.pal(9, "PuBu"))(length(unique_bacteria_classes)) 
palette_amf <- colorRampPalette(brewer.pal(9, "YlOrRd"))(length(unique_amf_species)) 

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)
species_colors_amf <- setNames(palette_amf, unique_amf_species)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_ground_class]
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_ground_class]
node_colors_amf <- species_colors_amf[taxonomy_amf_ground_species]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_bacteria, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_names))       # 真菌のノードの形
shapes_bacteria <- rep("square", length(bacteria_names))  # バクテリアのノードの形
shapes_amf <- rep("crectangle", length(amf_names))  # amfのノードの形
node_shapes <- c(shapes_fungi, shapes_bacteria, shapes_amf)

# 8. エッジのないノードを削除
g_ground_total <- delete_vertices(g_ground_total, degree(g_ground_total) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_ground_total)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_names) {
    return(class_colors_fungi[taxonomy_fungi_ground_class[match(node_name, fungi_names)]])
  } else if (node_name %in% bacteria_names) {
    return(class_colors_bacteria[taxonomy_bacteria_ground_class[match(node_name, bacteria_names)]])
  } else if (node_name %in% amf_names) {
    return(species_colors_amf[taxonomy_amf_ground_species[match(node_name, amf_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_names))
remaining_node_shapes_bacteria <- rep("square", sum(remaining_node_names %in% bacteria_names))
remaining_node_shapes_amf <- rep("csquare", sum(remaining_node_names %in% amf_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_bacteria, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_ground_total)

# 各ノードの次数を取得
node_degrees <- degree(g_ground_total)

# ノードのサイズを平方根スケーリングで調整
V(g_ground_total)$size <- log(node_degrees + 1) * 2  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_ground_total, 
     layout = layout,
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.5),  # ノードの色と透明度
     vertex.size = V(g_ground_total)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("1209_ground_everything_class&species_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_bacteria_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# AMFの凡例を右下に配置
legend("bottomright", 
       legend = unique_amf_species,  # AMFのカテゴリ名
       fill = adjustcolor(species_colors_amf[unique_amf_species], alpha.f = 0.7),  # AMFの対応する色
       title = "AMF species",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_D_total)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_D_total)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_canopy_everything_D_0.6_ranking.csv", row.names = FALSE)

# 元のデータフレームをコピー
#taxonomy_bacteria_filtered_added <- taxonomy_bacteria_filtered
# 新しい列 "Species" を追加
#taxonomy_bacteria_filtered_added$Species <- NA  # NAで初期化
# タクソノミー情報を結合
#taxonomy_combined <- rbind(taxonomy_fungi_filtered, taxonomy_bacteria_filtered_added, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
#taxonomy_combined_with_asv <- taxonomy_combined %>%
#  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_canopy_everything_D_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

##### Module解析 for 三部グラフ ########
# Louvain法によるモジュール検出（全三部グラフに対して）
tri_partite_clusters <- cluster_louvain(g_canopy_D_total)
# モジュール度（modularity）の計算
modularity_total <- modularity(tri_partite_clusters)
# 結果を表示
cat("三部グラフ全体のモジュール度:", modularity_total, "\n")
# コミュニティごとのメンバーシップを取得
membership_total <- membership(tri_partite_clusters)
# コミュニティに応じたノードの色を割り当て
community_colors <- rainbow(max(membership_total))
node_colors <- community_colors[membership_total]

set.seed(10)

# 三部グラフのプロット（コミュニティごとの色分け）
plot(g_canopy_D_total, 
     layout = layout_with_fr(g_canopy_D_total),  # Fruchterman-Reingoldレイアウト
     vertex.color = node_colors,  # コミュニティごとの色分け
     vertex.size = log(degree(g_canopy_D_total) + 1) * 3 ,  # ノードサイズ
     vertex.shape = node_shapes,  # ノードの形
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
library(bipartite)
library(igraph)

# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
observed_connectance <- networklevel(adjacency_matrix, index = "connectance", weighted = TRUE)
print(observed_connectance)
# 入れ子度（NODF）の計算
observed_nodf <- nested(adjacency_matrix, method = "NODF")
print(observed_nodf)
# 相互作用特殊化度 (H2') の計算
observed_H2_value <- H2fun(adjacency_matrix, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(observed_H2_value)
# 各指標の実行
observed_edge_density <- edge_density(g_canopy_D_total)
observed_edge_count <- ecount(g_canopy_D_total)
observed_global_clustering <- transitivity(g_canopy_D_total, type = "global")
degrees <- degree(g_canopy_D_total)
observed_max_degree <- max(degrees)
observed_mean_degree <- mean(degrees)
observed_num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", observed_edge_density, "\n")
cat("エッジ数:", observed_edge_count, "\n")
cat("グローバルクラスタリング係数:", observed_global_clustering, "\n")
cat("最大degree数:", observed_max_degree, "\n")
cat("平均degree数:", observed_mean_degree, "\n")
cat("エッジ数10以上のノード数:", observed_num_high_degree_nodes, "\n")

#null model

# 指標を格納するためのベクトルを作成
random_connectance <- numeric(100)
random_nodf <- numeric(100)
random_modularity <- numeric(100)
random_h2 <- numeric(100)
random_edge_density <- numeric(100)
random_edge_count <- numeric(100)
random_global_clustering <- numeric(100)
random_max_degree <- numeric(100)
random_mean_degree <- numeric(100)
random_num_high_degree_nodes <- numeric(100)

set.seed(NULL)
for (i in 1:25) {
  # ランダムな三部グラフを生成
  random_graph <- erdos.renyi.game(vcount(g_ground_total), ecount(g_ground_total), type = "gnm")
  
  # ランダムグラフの品質チェック
  if (ecount(random_graph) == 0) next
  
  # 隣接行列を取得
  null_matrix <- as_adjacency_matrix(random_graph, sparse = FALSE)
  
  # 指標を計算
  random_modularity[i] <- modularity(cluster_louvain(random_graph))
  random_connectance[i] <- networklevel(null_matrix, index = "connectance", weighted = TRUE)
  random_nodf[i] <- nested(null_matrix, method = "NODF")
  #random_h2[i] <- H2fun(null_matrix, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
  random_edge_density[i] <- edge_density(random_graph)
  random_global_clustering[i] <- transitivity(random_graph, type = "global")
}

# Null Modelの平均と標準偏差を計算
mean_random_modularity <- mean(random_modularity)
sd_random_modularity <- sd(random_modularity)
mean_random_connectance <- mean(random_connectance)
sd_random_connectance <- sd(random_connectance)
mean_random_nodf <- mean(random_nodf)
sd_random_nodf <- sd(random_nodf)
mean_random_edge_density <- mean(random_edge_density)
sd_random_edge_density <- sd(random_edge_density)
mean_random_global_clustering <- mean(random_global_clustering)
sd_random_global_clustering <- sd(random_global_clustering)

# zスコアを計算
if (sd_random_modularity == 0) {
  z_modularity <- NA
} else {
  z_modularity <- (observed_modularity - mean_random_modularity) / sd_random_modularity
}
if (sd_random_connectance == 0) {
  z_connectance <- NA
} else {
  z_connectance <- (observed_connectance - mean_random_connectance) / sd_random_connectance
}
if (sd_random_nodf == 0) {
  z_nodf <- NA
} else {
  z_nodf <- (observed_nodf - mean_random_nodf) / sd_random_nodf
}
if (sd_random_edge_density == 0) {
  z_edge_density <- NA
} else {
  z_edge_density <- (observed_edge_density - mean_random_edge_density) / sd_random_edge_density
}
if (sd_random_global_clustering == 0) {
  z_connectance <- NA
} else {
  z_clustering <- (observed_clustering - mean_random_global_clustering) / sd_random_global_clustering
}

# p値を計算（片側検定）
p_modularity <- 2 * (1 - pnorm(abs(z_modularity)))
p_connectance <- 2 * (1 - pnorm(abs(z_connectance)))
p_nodf <- 2 * (1 - pnorm(abs(z_nodf)))
p_edge_density <- 2 * (1 - pnorm(abs(z_edge_density)))
p_clustering <- 2 * (1 - pnorm(abs(z_clustering)))

# 結果を表示
cat("モジュール度: zスコア =", z_modularity, ", p値 =", p_modularity, "\n")
cat("モジュール度: zスコア =", z_connectance, ", p値 =", p_connectance, "\n")
cat("モジュール度: zスコア =", z_nodf, ", p値 =", p_nodf, "\n")
cat("エッジ密度: zスコア =", z_edge_density, ", p値 =", p_edge_density, "\n")
cat("クラスタリング係数: zスコア =", z_clustering, ", p値 =", p_clustering, "\n")

##########################################################################################################################################################
##########################################################################################################################################################
##### 真菌＊細菌 #############################################################################################################################
##ground#######
#ground
# フィルタ後の真菌とバクテリアの列数を再定義
n_fungi_ground <- ncol(asv_fungi_ground)
n_bacteria_ground <- ncol(asv_bacteria_ground)
n_amf_ground <- ncol(asv_amf_ground)

# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_ground_table_filtered) %in% colnames(asv_fungi_ground))
n_bacteria_filtered <- sum(colnames(combined_ground_table_filtered) %in% colnames(asv_bacteria_ground))
n_amf_filtered <- sum(colnames(combined_ground_fa_table_filtered) %in% colnames(asv_amf_ground))

# これに基づいて、相関行列から正しいインデックスを取得
fungal_bacterial_ground_corr <- correlation_ground_matrix[1:n_fungi_filtered, (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)]
fungal_amf_ground_corr <- correlation_ground_fa_matrix[1:n_fungi_filtered, (n_fungi_filtered + 1):ncol(correlation_ground_fa_matrix)]
#bacterial_amf_ground_corr <- correlation_ground_ba_matrix[1:n_fungi_filtered, (n_fungi_filtered+1):(n_fungi_filtered+n_amf_filtered)]

# 隣接行列の作成（相関係数が0.4以上
adjacency_ground_fb <- ifelse(fungal_bacterial_ground_corr >= 0.6, 1, 0)
adjacency_ground_fa <- ifelse(fungal_amf_ground_corr >= 0.5, 1, 0)
#adjacency_ground_ba <- ifelse(bacterial_amf_ground_corr >= 0.5, 1, 0)
# グラフの作成
g_ground_fb <- graph_from_incidence_matrix(adjacency_ground_fb)
g_ground_fa <- graph_from_incidence_matrix(adjacency_ground_fa)
#g_ground_ba <- graph_from_incidence_matrix(adjacency_ground_ba)

# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
fungi_asv_ground_names <- rownames(fungal_bacterial_ground_corr)    # Fungal ASVs の行名
bacteria_asv_ground_names <- colnames(fungal_bacterial_ground_corr) # Bacterial ASVs の列名
#amf_asv_ground_names <- colnames(fungal_bacterial_ground_corr) # Bacterial ASVs の列名

# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_ground_fb)$name <- c(fungi_asv_ground_names, bacteria_asv_ground_names)
#V(g_ground_fa)$name <- c(fungi_asv_ground_names,amf_asv_ground_names)
#V(g_ground_ba)$name <- c(fungi_asv_ground_names, bacteria_asv_ground_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_ground_class <- taxonomy_fungi_filtered[rownames(fungal_bacterial_ground_corr), "Class"]
taxonomy_bacteria_ground_class <- taxonomy_bacteria_filtered[bacteria_asv_ground_names, "Class"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_ground_class)
unique_bacteria_classes <- unique(taxonomy_bacteria_ground_class)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_fungi_classes))  # "Set1" ベースの拡張パレット
palette_bacteria <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_bacteria_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_ground_class]
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_ground_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_bacteria)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_asv_ground_names))       # 真菌のノードの形
shapes_bacteria <- rep("square", length(bacteria_asv_ground_names))  # バクテリアのノードの形
node_shapes <- c(shapes_fungi, shapes_bacteria)

# 8. エッジのないノードを削除
g_ground_fb <- delete_vertices(g_ground_fb, degree(g_ground_fb) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_ground)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_asv_ground_names) {
    return(class_colors_fungi[taxonomy_fungi_ground_class[match(node_name, fungi_asv_ground_names)]])
  } else if (node_name %in% bacteria_asv_ground_names) {
    return(class_colors_bacteria[taxonomy_bacteria_ground_class[match(node_name, bacteria_asv_ground_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_asv_ground_names))
remaining_node_shapes_bacteria <- rep("square", sum(remaining_node_names %in% bacteria_asv_ground_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_bacteria)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_ground_fb)

# 各ノードの次数を取得
node_degrees <- degree(g_ground_fb)

# ノードのサイズを平方根スケーリングで調整
V(g_ground_fb)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_ground_fb, 
     layout = layout,
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_ground_fb)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("fungi_bacteria_class_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_bacteria_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()



# 各ノードの次数を計算
node_degrees <- degree(g_ground_fb)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_ground_fb)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_ground_f*b_0.6_ranking.csv", row.names = FALSE)

# taxonomy_bacteria_filteredの一番右の列を削除
taxonomy_fungi_filtered_trimmed <- taxonomy_fungi_filtered[, -ncol(taxonomy_fungi_filtered)]
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_fungi_filtered_trimmed, taxonomy_bacteria_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_ground_f*b_0.6_ranking_with_taxonomy.csv", row.names = FALSE)


#####Module解析###############
# 二部グラフのプロジェクションを作成
projection_result <- bipartite_projection(g_ground_fb)
# プロジェクション結果を確認
fungi_projection <- projection_result$proj1  # 真菌側のプロジェクション
bacteria_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(fungi_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
fungi_clusters <- cluster_louvain(fungi_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
bacteria_clusters <- cluster_louvain(bacteria_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_ground_fb)
# モジュール度（modularity）の計算
modularity_fungi <- modularity(fungi_clusters)
modularity_bacteria <- modularity(bacteria_clusters)
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_fungi)
print(modularity_bacteria)
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_ground_fb, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_ground_fb)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示


#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
library(bipartite)
library(igraph)

# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_ground_fb, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_ground_fb, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_ground_fb, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# ノード数とエッジ数を指定
num_nodes <- vcount(g_ground_fb)  # 真菌とバクテリアを合わせたノード数
num_edges <- ecount(g_ground_fb)  # エッジ数

# 指標を格納するためのベクトルを作成
random_connectance <- numeric(100)
random_nodf <- numeric(100)
random_modularity <- numeric(100)
random_h2 <- numeric(100)

set.seed(123)  # 再現性のためのシード設定

for (i in 1:100) {
  # ランダムなネットワークを生成（エッジ数を指定）
  random_graph <- erdos.renyi.game(num_nodes, num_edges, type = "gnm")
  
  # 隣接行列を取得
  adjacency_matrix <- as_adjacency_matrix(random_graph, sparse = FALSE)
  
  # ランダムネットワークの指標を計算
  random_connectance[i] <- networklevel(adjacency_matrix, index = "connectance")
  random_nodf[i] <- nested(adjacency_matrix, method = "NODF")
  random_modularity[i] <- modularity(cluster_louvain(random_graph))
  random_h2[i] <- H2fun(adjacency_matrix, H2_integer = TRUE)$H2
}

# ランダムネットワークの平均と標準偏差を計算
mean_random_connectance <- mean(random_connectance)
sd_random_connectance <- sd(random_connectance)
mean_random_nodf <- mean(random_nodf)
sd_random_nodf <- sd(random_nodf)
mean_random_modularity <- mean(random_modularity)
sd_random_modularity <- sd(random_modularity)
#mean_random_h2 <- mean(random_h2)
#sd_random_h2 <- sd(random_h2)

# zスコアの計算
z_connectance <- (weighted_connectance - mean_random_connectance) / sd_random_connectance
z_nodf <- (weighted_nodf - mean_random_nodf) / sd_random_nodf
z_modularity <- (modularity_bipartite - mean_random_modularity) / sd_random_modularity
#z_h2 <- (observed_h2["H2"] - mean_random_h2) / sd_random_h2

# p値の計算（片側検定）
p_connectance <- 2 * (1 - pnorm(abs(z_connectance)))
p_nodf <- 2 * (1 - pnorm(abs(z_nodf)))
p_modularity <- 2 * (1 - pnorm(abs(z_modularity)))
#p_h2 <- 2 * (1 - pnorm(abs(z_h2)))

# 結果の表示
cat("Connectance: zスコア =", z_connectance, ", p値 =", format(p_connectance, scientific = TRUE), "\n")
cat("NODF: zスコア =", z_nodf, ", p値 =", format(p_nodf, scientific = TRUE), "\n")
cat("Modularity: zスコア =", z_modularity, ", p値 =", format(p_modularity, scientific = TRUE), "\n")
#cat("H2': zスコア =", z_h2, ", p値 =", p_h2, "\n")

# 各指標の実行
edge_density_value <- edge_density(g_ground_fb)
edge_count <- ecount(g_ground_fb)
global_clustering <- transitivity(g_ground_fb, type = "global")
degrees <- degree(g_ground_fb)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

###canopy####
# フィルタ後の真菌とバクテリアの列数を再定義
n_fungi_canopy <- ncol(asv_fungi_canopy)
n_bacteria_canopy <- ncol(asv_bacteria_canopy)

# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_canopy_table_filtered) %in% colnames(asv_fungi_canopy))
n_bacteria_filtered <- sum(colnames(combined_canopy_table_filtered) %in% colnames(asv_bacteria_canopy))

# これに基づいて、相関行列から正しいインデックスを取得
fungal_bacterial_canopy_corr <- correlation_canopy_matrix[1:n_fungi_filtered, (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)]

# 隣接行列の作成（相関係数が0.4以上）
adjacency_canopy_fb <- ifelse(fungal_bacterial_canopy_corr >= 0.6, 1, 0)

# グラフの作成
g_canopy_fb <- graph_from_incidence_matrix(adjacency_canopy_fb)
# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
fungi_asv_canopy_names <- rownames(fungal_bacterial_canopy_corr)    # Fungal ASVs の行名
bacteria_asv_canopy_names <- colnames(fungal_bacterial_canopy_corr) # Bacterial ASVs の列名
# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_fb)$name <- c(fungi_asv_canopy_names, bacteria_asv_canopy_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_canopy_class <- taxonomy_fungi_filtered[rownames(fungal_bacterial_canopy_corr), "Class"]
taxonomy_bacteria_canopy_class <- taxonomy_bacteria_filtered[bacteria_asv_canopy_names, "Class"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_canopy_class)
unique_bacteria_classes <- unique(taxonomy_bacteria_canopy_class)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_fungi_classes))  # "Set1" ベースの拡張パレット
palette_bacteria <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_bacteria_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_canopy_class]
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_canopy_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_bacteria)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_asv_canopy_names))       # 真菌のノードの形
shapes_bacteria <- rep("square", length(bacteria_asv_canopy_names))  # バクテリアのノードの形
node_shapes <- c(shapes_fungi, shapes_bacteria)

# 8. エッジのないノードを削除
g_canopy_fb <- delete_vertices(g_canopy_fb, degree(g_canopy_fb) == 0)
 
# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_fb)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_asv_canopy_names) {
    return(class_colors_fungi[taxonomy_fungi_canopy_class[match(node_name, fungi_asv_canopy_names)]])
  } else if (node_name %in% bacteria_asv_canopy_names) {
    return(class_colors_bacteria[taxonomy_bacteria_canopy_class[match(node_name, bacteria_asv_canopy_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})
 
# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_asv_canopy_names))
remaining_node_shapes_bacteria <- rep("square", sum(remaining_node_names %in% bacteria_asv_canopy_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_bacteria)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_fb)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_fb)

# 対数スケーリングでノードサイズを調整
V(g_canopy_fb)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)
 
# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_fb, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_fb)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("fungi_bacteria_class_canopy_0.6_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_bacteria_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_fb)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_fb)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_canopy_f*b_0.6_ranking.csv", row.names = FALSE)

# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_canopy_f*b_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

#####Module解析###############
# 二部グラフのプロジェクションを作成  
projection_result <- bipartite_projection(g_canopy_fb)
# プロジェクション結果を確認
fungi_projection <- projection_result$proj1  # 真菌側のプロジェクション
bacteria_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(fungi_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
fungi_clusters <- cluster_louvain(fungi_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
bacteria_clusters <- cluster_louvain(bacteria_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_fb)
# モジュール度（modularity）の計算
modularity_fungi <- modularity(fungi_clusters)
modularity_bacteria <- modularity(bacteria_clusters)
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_fungi)
print(modularity_bacteria)
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_fb, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_fb)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_fb, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_fb, method = "NODF")
print(weighted_nodf)
# 隣接行列の重みの正規化
adjacency_matrix_normalized <- adjacency_canopy_fb / max(adjacency_canopy_fb)
weighted_nodf <- nested(adjacency_matrix_normalized, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_fb, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# 各指標の実行
edge_density_value <- edge_density(g_canopy_fb)
edge_count <- ecount(g_canopy_fb)
global_clustering <- transitivity(g_canopy_fb, type = "global")
degrees <- degree(g_canopy_fb)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

#### TWINASPAN A F*B ################################################################################
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_canopy_table_filtered_A) %in% colnames(asv_fungi_canopy))
n_bacteria_filtered <- sum(colnames(combined_canopy_table_filtered_A) %in% colnames(asv_bacteria_canopy))

# これに基づいて、相関行列から正しいインデックスを取得
fungal_bacterial_A_corr <- correlation_canopy_A_matrix[1:n_fungi_filtered, (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)]

# 隣接行列の作成（相関係数が0.4以上）
adjacency_canopy_A_fb <- ifelse(fungal_bacterial_A_corr >= 0.6, 1, 0)

# グラフの作成
g_canopy_A_fb <- graph_from_incidence_matrix(adjacency_canopy_A_fb)
# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
fungi_asv_A_names <- rownames(fungal_bacterial_A_corr)    # Fungal ASVs の行名
bacteria_asv_A_names <- colnames(fungal_bacterial_A_corr) # Bacterial ASVs の列名
# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_A_fb)$name <- c(fungi_asv_A_names, bacteria_asv_A_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_A_class <- taxonomy_fungi_filtered[rownames(fungal_bacterial_A_corr), "Class"]
taxonomy_bacteria_A_class <- taxonomy_bacteria_filtered[bacteria_asv_A_names, "Class"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_A_class)
unique_bacteria_classes <- unique(taxonomy_bacteria_A_class)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_fungi_classes))  # "Set1" ベースの拡張パレット
palette_bacteria <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_bacteria_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_A_class]
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_A_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_bacteria)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_asv_A_names))       # 真菌のノードの形
shapes_bacteria <- rep("square", length(bacteria_asv_A_names))  # バクテリアのノードの形
node_shapes <- c(shapes_fungi, shapes_bacteria)

# 8. エッジのないノードを削除
g_canopy_A_fb <- delete_vertices(g_canopy_A_fb, degree(g_canopy_A_fb) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_A_fb)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_asv_A_names) {
    return(class_colors_fungi[taxonomy_fungi_A_class[match(node_name, fungi_asv_A_names)]])
  } else if (node_name %in% bacteria_asv_A_names) {
    return(class_colors_bacteria[taxonomy_bacteria_A_class[match(node_name, bacteria_asv_A_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_asv_A_names))
remaining_node_shapes_bacteria <- rep("square", sum(remaining_node_names %in% bacteria_asv_A_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_bacteria)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_A_fb)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_A_fb)

# 対数スケーリングでノードサイズを調整
V(g_canopy_A_fb)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_A_fb, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_A_fb)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("fungi_bacteria_class_TWINSPAN_A_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_bacteria_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_A_fb)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_A_fb)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_TWINSPAN_A_f*b_0.6_ranking.csv", row.names = FALSE)

# taxonomy_bacteria_filteredの一番右の列(Speciesの列)を削除
taxonomy_fungi_filtered_trimmed <- taxonomy_fungi_filtered[, -ncol(taxonomy_fungi_filtered)]
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_fungi_filtered_trimmed, taxonomy_bacteria_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_A_f*b_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

# Module解析###############
# 二部グラフのプロジェクションを作成  
projection_result <- bipartite_projection(g_canopy_A_fb)
# プロジェクション結果を確認
fungi_projection <- projection_result$proj1  # 真菌側のプロジェクション
bacteria_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(fungi_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
fungi_clusters <- cluster_louvain(fungi_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
bacteria_clusters <- cluster_louvain(bacteria_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_A_fb)
# モジュール度（modularity）の計算
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_A_fb, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_A_fb)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示

##重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_A_fb, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_A_fb, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_A_fb, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# 各指標の実行
edge_density_value <- edge_density(g_canopy_A_fb)
edge_count <- ecount(g_canopy_A_fb)
global_clustering <- transitivity(g_canopy_A_fb, type = "global")
degrees <- degree(g_canopy_A_fb)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

#### TWINASPAN B F*B ################################################################################
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_canopy_table_filtered_B) %in% colnames(asv_fungi_canopy))
n_bacteria_filtered <- sum(colnames(combined_canopy_table_filtered_B) %in% colnames(asv_bacteria_canopy))

# これに基づいて、相関行列から正しいインデックスを取得
fungal_bacterial_B_corr <- correlation_canopy_B_matrix[1:n_fungi_filtered, (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)]

# 隣接行列の作成（相関係数が0.4以上）
adjacency_canopy_B_fb <- ifelse(fungal_bacterial_B_corr >= 0.6, 1, 0)

# グラフの作成
g_canopy_B_fb <- graph_from_incidence_matrix(adjacency_canopy_B_fb)
# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
fungi_asv_B_names <- rownames(fungal_bacterial_B_corr)    # Fungal ASVs の行名
bacteria_asv_B_names <- colnames(fungal_bacterial_B_corr) # Bacterial ASVs の列名
# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_B_fb)$name <- c(fungi_asv_B_names, bacteria_asv_B_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_B_class <- taxonomy_fungi_filtered[rownames(fungal_bacterial_B_corr), "Class"]
taxonomy_bacteria_B_class <- taxonomy_bacteria_filtered[bacteria_asv_B_names, "Class"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_B_class)
unique_bacteria_classes <- unique(taxonomy_bacteria_B_class)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_fungi_classes))  # "Set1" ベースの拡張パレット
palette_bacteria <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_bacteria_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_B_class]
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_B_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_bacteria)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_asv_B_names))       # 真菌のノードの形
shapes_bacteria <- rep("square", length(bacteria_asv_B_names))  # バクテリアのノードの形
node_shapes <- c(shapes_fungi, shapes_bacteria)

# 8. エッジのないノードを削除
g_canopy_B_fb <- delete_vertices(g_canopy_B_fb, degree(g_canopy_B_fb) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_B_fb)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_asv_B_names) {
    return(class_colors_fungi[taxonomy_fungi_B_class[match(node_name, fungi_asv_B_names)]])
  } else if (node_name %in% bacteria_asv_B_names) {
    return(class_colors_bacteria[taxonomy_bacteria_B_class[match(node_name, bacteria_asv_B_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_asv_B_names))
remaining_node_shapes_bacteria <- rep("square", sum(remaining_node_names %in% bacteria_asv_B_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_bacteria)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_B_fb)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_B_fb)

# 対数スケーリングでノードサイズを調整
V(g_canopy_B_fb)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_B_fb, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_B_fb)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("fungi_bacteria_class_TWINSPAN_B_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_bacteria_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_B_fb)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_B_fb)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_TWINSPAN_B_f*b_0.6_ranking.csv", row.names = FALSE)

# taxonomy_bacteria_filteredの一番右の列(Speciesの列)を削除
taxonomy_fungi_filtered_trimmed <- taxonomy_fungi_filtered[, -ncol(taxonomy_fungi_filtered)]
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_fungi_filtered_trimmed, taxonomy_bacteria_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_B_f*b_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

#####Module解析###############
# 二部グラフのプロジェクションを作成  
projection_result <- bipartite_projection(g_canopy_B_fb)
# プロジェクション結果を確認
fungi_projection <- projection_result$proj1  # 真菌側のプロジェクション
bacteria_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(fungi_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
fungi_clusters <- cluster_louvain(fungi_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
bacteria_clusters <- cluster_louvain(bacteria_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_B_fb)
# モジュール度（modularity）の計算
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_B_fb, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_B_fb)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_B_fb, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_B_fb, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_B_fb, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# 各指標の実行
edge_density_value <- edge_density(g_canopy_B_fb)
edge_count <- ecount(g_canopy_B_fb)
global_clustering <- transitivity(g_canopy_B_fb, type = "global")
degrees <- degree(g_canopy_B_fb)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")


  
#### TWINASPAN C F*B ################################################################################
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_canopy_table_filtered_C) %in% colnames(asv_fungi_canopy))
n_bacteria_filtered <- sum(colnames(combined_canopy_table_filtered_C) %in% colnames(asv_bacteria_canopy))

# これに基づいて、相関行列から正しいインデックスを取得
fungal_bacterial_C_corr <- correlation_canopy_C_matrix[1:n_fungi_filtered, (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)]

# 隣接行列の作成（相関係数が0.4以上）
adjacency_canopy_C_fb <- ifelse(fungal_bacterial_C_corr >= 0.6, 1, 0)

# グラフの作成
g_canopy_C_fb <- graph_from_incidence_matrix(adjacency_canopy_C_fb)
# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
fungi_asv_C_names <- rownames(fungal_bacterial_C_corr)    # Fungal ASVs の行名
bacteria_asv_C_names <- colnames(fungal_bacterial_C_corr) # Bacterial ASVs の列名
# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_C_fb)$name <- c(fungi_asv_C_names, bacteria_asv_C_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_C_class <- taxonomy_fungi_filtered[rownames(fungal_bacterial_C_corr), "Class"]
taxonomy_bacteria_C_class <- taxonomy_bacteria_filtered[bacteria_asv_C_names, "Class"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_C_class)
unique_bacteria_classes <- unique(taxonomy_bacteria_C_class)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_fungi_classes))  # "Set1" ベースの拡張パレット
palette_bacteria <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_bacteria_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_C_class]
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_C_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_bacteria)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_asv_C_names))       # 真菌のノードの形
shapes_bacteria <- rep("square", length(bacteria_asv_C_names))  # バクテリアのノードの形
node_shapes <- c(shapes_fungi, shapes_bacteria)

# 8. エッジのないノードを削除
g_canopy_C_fb <- delete_vertices(g_canopy_C_fb, degree(g_canopy_C_fb) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_C_fb)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_asv_C_names) {
    return(class_colors_fungi[taxonomy_fungi_C_class[match(node_name, fungi_asv_C_names)]])
  } else if (node_name %in% bacteria_asv_C_names) {
    return(class_colors_bacteria[taxonomy_bacteria_C_class[match(node_name, bacteria_asv_C_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_asv_C_names))
remaining_node_shapes_bacteria <- rep("square", sum(remaining_node_names %in% bacteria_asv_C_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_bacteria)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_C_fb)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_C_fb)

# 対数スケーリングでノードサイズを調整
V(g_canopy_C_fb)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_C_fb, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_C_fb)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("fungi_bacteria_class_TWINSPAN_C_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_bacteria_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_C_fb)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_C_fb)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_TWINSPAN_C_f*b_0.6_ranking.csv", row.names = FALSE)

# taxonomy_bacteria_filteredの一番右の列(Speciesの列)を削除
taxonomy_fungi_filtered_trimmed <- taxonomy_fungi_filtered[, -ncol(taxonomy_fungi_filtered)]
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_fungi_filtered_trimmed, taxonomy_bacteria_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_C_f*b_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

#####Module解析###############
# 二部グラフのプロジェクションを作成  
projection_result <- bipartite_projection(g_canopy_C_fb)
# プロジェクション結果を確認
fungi_projection <- projection_result$proj1  # 真菌側のプロジェクション
bacteria_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(fungi_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
fungi_clusters <- cluster_louvain(fungi_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
bacteria_clusters <- cluster_louvain(bacteria_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_C_fb)
# モジュール度（modularity）の計算
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_C_fb, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_C_fb)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_C_fb, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_C_fb, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_C_fb, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# 各指標の実行
edge_density_value <- edge_density(g_canopy_C_fb)
edge_count <- ecount(g_canopy_C_fb)
global_clustering <- transitivity(g_canopy_B_fb, type = "global")
degrees <- degree(g_canopy_C_fb)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

#### TWINASPAN D F*B ################################################################################
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_canopy_table_filtered_D) %in% colnames(asv_fungi_canopy))
n_bacteria_filtered <- sum(colnames(combined_canopy_table_filtered_D) %in% colnames(asv_bacteria_canopy))

# これに基づいて、相関行列から正しいインデックスを取得
fungal_bacterial_D_corr <- correlation_canopy_D_matrix[1:n_fungi_filtered, (n_fungi_filtered+1):(n_fungi_filtered+n_bacteria_filtered)]

# 隣接行列の作成（相関係数が0.4以上）
adjacency_canopy_D_fb <- ifelse(fungal_bacterial_D_corr >= 0.6, 1, 0)

# グラフの作成
g_canopy_D_fb <- graph_from_incidence_matrix(adjacency_canopy_D_fb)
# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
fungi_asv_D_names <- rownames(fungal_bacterial_D_corr)    # Fungal ASVs の行名
bacteria_asv_D_names <- colnames(fungal_bacterial_D_corr) # Bacterial ASVs の列名
# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_D_fb)$name <- c(fungi_asv_D_names, bacteria_asv_D_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_D_class <- taxonomy_fungi_filtered[rownames(fungal_bacterial_D_corr), "Class"]
taxonomy_bacteria_D_class <- taxonomy_bacteria_filtered[bacteria_asv_D_names, "Class"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_D_class)
unique_bacteria_classes <- unique(taxonomy_bacteria_D_class)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_fungi_classes))  # "Set1" ベースの拡張パレット
palette_bacteria <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_bacteria_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_D_class]
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_D_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_bacteria)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_asv_D_names))       # 真菌のノードの形
shapes_bacteria <- rep("square", length(bacteria_asv_D_names))  # バクテリアのノードの形
node_shapes <- c(shapes_fungi, shapes_bacteria)

# 8. エッジのないノードを削除
g_canopy_D_fb <- delete_vertices(g_canopy_D_fb, degree(g_canopy_D_fb) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_D_fb)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_asv_D_names) {
    return(class_colors_fungi[taxonomy_fungi_D_class[match(node_name, fungi_asv_D_names)]])
  } else if (node_name %in% bacteria_asv_D_names) {
    return(class_colors_bacteria[taxonomy_bacteria_D_class[match(node_name, bacteria_asv_D_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_asv_D_names))
remaining_node_shapes_bacteria <- rep("square", sum(remaining_node_names %in% bacteria_asv_D_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_bacteria)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_D_fb)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_D_fb)

# 対数スケーリングでノードサイズを調整
V(g_canopy_D_fb)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_D_fb, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_D_fb)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("fungi_bacteria_class_TWINSPAN_D_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_bacteria_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_D_fb)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_D_fb)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_TWINSPAN_D_f*b_0.6_ranking.csv", row.names = FALSE)

# taxonomy_bacteria_filteredの一番右の列(Speciesの列)を削除
taxonomy_fungi_filtered_trimmed <- taxonomy_fungi_filtered[, -ncol(taxonomy_fungi_filtered)]
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_fungi_filtered_trimmed, taxonomy_bacteria_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_D_f*b_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

#####Module解析###############
# 二部グラフのプロジェクションを作成  
projection_result <- bipartite_projection(g_canopy_D_fb)
# プロジェクション結果を確認
fungi_projection <- projection_result$proj1  # 真菌側のプロジェクション
bacteria_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(fungi_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
fungi_clusters <- cluster_louvain(fungi_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
bacteria_clusters <- cluster_louvain(bacteria_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_D_fb)
# モジュール度（modularity）の計算
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_D_fb, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_D_fb)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_D_fb, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_D_fb, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_D_fb, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# 各指標の実行
edge_density_value <- edge_density(g_canopy_D_fb)
edge_count <- ecount(g_canopy_D_fb)
global_clustering <- transitivity(g_canopy_D_fb, type = "global")
degrees <- degree(g_canopy_D_fb)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")
  
### 真菌＊AMF #############################################################################################################################
#fungaltraitsも並行して実施
#####ground#######
#ground
# フィルタ後の真菌とバクテリアの列数を再定義
n_fungi_ground <- ncol(asv_fungi_ground)
n_bacteria_ground <- ncol(asv_bacteria_ground)
n_amf_ground <- ncol(asv_amf_ground)

# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_fa_filtered <- sum(colnames(combined_ground_fa_table_filtered) %in% colnames(asv_fungi_ground))
n_amf_fa_filtered <- sum(colnames(combined_ground_fa_table_filtered) %in% colnames(asv_amf_ground))

# これに基づいて、相関行列から正しいインデックスを取得
fungal_amf_ground_corr <- correlation_ground_fa_matrix[1:n_fungi_fa_filtered, (n_fungi_fa_filtered + 1):ncol(correlation_ground_fa_matrix)]

# 隣接行列の作成（相関係数が0.4以上
adjacency_ground_fa <- ifelse(fungal_amf_ground_corr >= 0.6, 1, 0)
# グラフの作成
g_ground_fa <- graph_from_incidence_matrix(adjacency_ground_fa)

# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
fungi_asv_ground_names <- rownames(fungal_amf_ground_corr)    # Fungal ASVs の行名
amf_asv_ground_names <- colnames(fungal_amf_ground_corr) # Bacterial ASVs の列名

# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_ground_fa)$name <- c(fungi_asv_ground_names, amf_asv_ground_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_ground_class <- taxonomy_fungi_filtered[rownames(fungal_bacterial_ground_corr), "Class"]
taxonomy_amf_ground_class <- taxonomy_amf_filtered[amf_asv_ground_names, "Class"]

fungaltraits_ground_lifestyle <- function_fungi_filtered[rownames(fungal_bacterial_ground_corr), "primary_lifestyle"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_ground_class)
unique_amf_classes <- unique(taxonomy_amf_ground_class)

unique_fungi_lifestyle <- unique(fungaltraits_ground_lifestyle)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_fungi_classes))  # "Set1" ベースの拡張パレット
palette_amf <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_amf_classes))  # "Set3" ベースの拡張パレット

palette_lifestyle <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_fungi_lifestyle))  # "Set1" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_amf <- setNames(palette_amf, unique_amf_classes)

lifestyle_colors <- setNames(palette_lifestyle, unique_fungi_lifestyle)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_ground_class]
node_colors_amf <- class_colors_amf[taxonomy_amf_ground_class]

node_colors_lifestyle <- lifestyle_colors[fungaltraits_ground_lifestyle]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_amf)
node_colors_for_function <- c(node_colors_lifestyle, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_asv_ground_names))       # 真菌のノードの形
shapes_amf <- rep("square", length(amf_asv_ground_names))  # バクテリアのノードの形
node_shapes <- c(shapes_fungi, shapes_amf)

# 8. エッジのないノードを削除
g_ground_fa <- delete_vertices(g_ground_fa, degree(g_ground_fa) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_ground_fa)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_asv_ground_names) {
    return(class_colors_fungi[taxonomy_fungi_ground_class[match(node_name, fungi_asv_ground_names)]])
  } else if (node_name %in% amf_asv_ground_names) {
    return(class_colors_amf[taxonomy_amf_ground_class[match(node_name, amf_asv_ground_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_asv_ground_names))
remaining_node_shapes_amf <- rep("square", sum(remaining_node_names %in% amf_asv_ground_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_ground_fa)

# 各ノードの次数を取得
node_degrees <- degree(g_ground_fa)

# ノードのサイズを平方根スケーリングで調整
V(g_ground_fa)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_ground_fa, 
     layout = layout,
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_ground_fa)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("fungi_amf_class_ground_0.6_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# amfの凡例を右上に配置
legend("topright", 
       legend = unique_amf_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_amf[unique_amf_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "AMF Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()


# 各ノードの次数を計算
node_degrees <- degree(g_ground_fa)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_ground_fa)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_ground_f*a_0.6_ranking.csv", row.names = FALSE)

# taxonomy_amf_filteredの一番右の列を削除
taxonomy_amf_filtered_trimmed <- taxonomy_amf_filtered[, -ncol(taxonomy_amf_filtered)]
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_fungi_filtered, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_ground_f*a_0.6_ranking_with_taxonomy.csv", row.names = FALSE)


#####Module解析###############
# 二部グラフのプロジェクションを作成
projection_result <- bipartite_projection(g_ground_fa)
# プロジェクション結果を確認
fungi_projection <- projection_result$proj1  # 真菌側のプロジェクション
amf_projection <- projection_result$proj2  # amf側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(fungi_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
fungi_clusters <- cluster_louvain(fungi_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
amf_clusters <- cluster_louvain(amf_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_ground_fa)
# モジュール度（modularity）の計算
modularity_fungi <- modularity(fungi_clusters)
modularity_amf <- modularity(amf_clusters)
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_ground_fa, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_ground_fa)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示


#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
library(bipartite)
library(igraph)
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_ground_fa, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_ground_fa, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_ground_fa, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# ノード数とエッジ数を指定
num_nodes <- vcount(g_ground_fa)  # 真菌とバクテリアを合わせたノード数
num_edges <- ecount(g_ground_fa)  # エッジ数

# 指標を格納するためのベクトルを作成
random_connectance <- numeric(100)
random_nodf <- numeric(100)
random_modularity <- numeric(100)
random_h2 <- numeric(100)

set.seed(130)  # 再現性のためのシード設定

for (i in 1:100) {
  # ランダムなネットワークを生成（エッジ数を指定）
  random_graph <- erdos.renyi.game(num_nodes, num_edges, type = "gnm")
  
  # 隣接行列を取得
  adjacency_matrix <- as_adjacency_matrix(random_graph, sparse = FALSE)
  
  # ランダムネットワークの指標を計算
  random_connectance[i] <- networklevel(adjacency_matrix, index = "connectance")
  random_nodf[i] <- nested(adjacency_matrix, method = "NODF")
  random_modularity[i] <- modularity(cluster_louvain(random_graph))
  #random_h2[i] <- H2fun(adjacency_matrix, H2_integer = TRUE)$H2
}

# ランダムネットワークの平均と標準偏差を計算
mean_random_connectance <- mean(random_connectance)
sd_random_connectance <- sd(random_connectance)
mean_random_nodf <- mean(random_nodf)
sd_random_nodf <- sd(random_nodf)
mean_random_modularity <- mean(random_modularity)
sd_random_modularity <- sd(random_modularity)
#mean_random_h2 <- mean(random_h2)
#sd_random_h2 <- sd(random_h2)

# zスコアの計算
z_connectance <- (observed_connectance - mean_random_connectance) / sd_random_connectance
z_nodf <- (observed_nodf - mean_random_nodf) / sd_random_nodf
z_modularity <- (observed_modularity - mean_random_modularity) / sd_random_modularity
#z_h2 <- (observed_h2["H2"] - mean_random_h2) / sd_random_h2

# p値の計算（片側検定）
p_connectance <- 2 * (1 - pnorm(abs(z_connectance)))
p_nodf <- 2 * (1 - pnorm(abs(z_nodf)))
p_modularity <- 2 * (1 - pnorm(abs(z_modularity)))
#p_h2 <- 2 * (1 - pnorm(abs(z_h2)))

# 結果の表示
cat("Connectance: zスコア =", z_connectance, ", p値 =", format(p_connectance, scientific = TRUE), "\n")
cat("NODF: zスコア =", z_nodf, ", p値 =", format(p_nodf, scientific = TRUE), "\n")
cat("Modularity: zスコア =", z_modularity, ", p値 =", format(p_modularity, scientific = TRUE), "\n")
#cat("H2': zスコア =", z_h2, ", p値 =", p_h2, "\n")

# bipartite パッケージをアンロードする場合は！
detach("package:bipartite", unload = TRUE)

# sna パッケージをアンロードする場合は！
detach("package:sna", unload = TRUE)

# 各指標の実行
edge_density_value <- edge_density(g_ground_fa)
edge_count <- ecount(g_ground_fa)
global_clustering <- transitivity(g_ground_fa, type = "global")
degrees <- degree(g_ground_fa)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")


###canopy####

# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_fa_filtered <- sum(colnames(combined_canopy_fa_table_filtered) %in% colnames(asv_fungi_ground))
n_amf_fa_filtered <- sum(colnames(combined_canopy_fa_table_filtered) %in% colnames(asv_amf_ground))

# これに基づいて、相関行列から正しいインデックスを取得
fungal_amf_canopy_corr <- correlation_canopy_fa_matrix[1:n_fungi_fa_filtered, (n_fungi_fa_filtered+1):(n_fungi_fa_filtered+n_amf_fa_filtered)]

# 隣接行列の作成（相関係数が0.4以上）
adjacency_canopy_fa <- ifelse(fungal_amf_canopy_corr >= 0.6, 1, 0)
# グラフの作成
g_canopy_fa <- graph_from_incidence_matrix(adjacency_canopy_fa)

# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
fungi_asv_canopy_names <- rownames(fungal_amf_canopy_corr)    # Fungal ASVs の行名
amf_asv_canopy_names <- colnames(fungal_amf_canopy_corr) # amf ASVs の列名
# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_fa)$name <- c(fungi_asv_canopy_names, amf_asv_canopy_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_canopy_class <- taxonomy_fungi_filtered[fungi_asv_canopy_names, "Class"]
taxonomy_amf_canopy_class <- taxonomy_amf_filtered[amf_asv_canopy_names, "Class"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_canopy_class)
unique_amf_classes <- unique(taxonomy_amf_canopy_class)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_fungi_classes))  # "Set1" ベースの拡張パレット
palette_amf <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_amf_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_amf <- setNames(palette_amf, unique_amf_classes)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_canopy_class]
node_colors_amf <- class_colors_amf[taxonomy_amf_canopy_class]

# 6.5. Fungal ASVsとamf ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_asv_canopy_names))       # 真菌のノードの形
shapes_amf <- rep("square", length(amf_asv_canopy_names))  # バクテリアのノードの形
node_shapes <- c(shapes_fungi, shapes_amf)

# 8. エッジのないノードを削除
g_canopy_fa <- delete_vertices(g_canopy_fa, degree(g_canopy_fa) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_fa)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_asv_canopy_names) {
    return(class_colors_fungi[taxonomy_fungi_canopy_class[match(node_name, fungi_asv_canopy_names)]])
  } else if (node_name %in% amf_asv_canopy_names) {
    return(class_colors_amf[taxonomy_amf_canopy_class[match(node_name,amf_asv_canopy_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_asv_canopy_names))
remaining_node_shapes_amf <- rep("square", sum(remaining_node_names %in% amf_asv_canopy_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_fa)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_fa)

# 対数スケーリングでノードサイズを調整
V(g_canopy_fa)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_fa, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_fa)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("fungi_amf_class_canopy_0.6_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# amfの凡例を右上に配置
legend("topright", 
       legend = unique_amf_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_amf[unique_amf_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "AMF Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_fa)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_fa)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_canopy_f*a_0.6_ranking.csv", row.names = FALSE)

# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_canopy_f*a_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

#####Module解析###############
# 二部グラフのプロジェクションを作成  
projection_result <- bipartite_projection(g_canopy_fa)
# プロジェクション結果を確認
fungi_projection <- projection_result$proj1  # 真菌側のプロジェクション
amf_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(fungi_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
fungi_clusters <- cluster_louvain(fungi_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
amf_clusters <- cluster_louvain(amf_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_fa)
# モジュール度（modularity）の計算
modularity_fungi <- modularity(fungi_clusters)
modularity_amf <- modularity(amf_clusters)
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_fa, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_fa)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
library(bipartite)
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_fa, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_fa, method = "NODF")
print(weighted_nodf)
# 隣接行列の重みの正規化
adjacency_matrix_normalized <- adjacency_canopy_fa / max(adjacency_canopy_fa)
weighted_nodf <- nested(adjacency_matrix_normalized, method = "NODF")
print(weighted_nodf)
# モジュール度の計算
module_result <- computeModules(adjacency_canopy_fa)
modularity_value <- module_result@likelihood
print(modularity_value)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_fa, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# bipartite パッケージをアンロードする場合は！
detach("package:bipartite", unload = TRUE)

# sna パッケージをアンロードする場合は！
detach("package:sna", unload = TRUE)

edge_density_value <- edge_density(g_canopy_fa)
edge_count <- ecount(g_canopy_fa)
global_clustering <- transitivity(g_canopy_fa, type = "global")
degrees <- degree(g_canopy_fa)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

#### TWINASPAN A F*A ################################################################################
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_fa_filtered <- sum(colnames(combined_canopy_fa_table_filtered_A) %in% colnames(asv_fungi_canopy))
n_amf_fa_filtered <- sum(colnames(combined_canopy_fa_table_filtered_A) %in% colnames(asv_amf_canopy))

# これに基づいて、相関行列から正しいインデックスを取得
fungal_amf_canopy_A_corr <- correlation_canopy_fa_A_matrix[1:n_fungi_fa_filtered, (n_fungi_fa_filtered+1):(n_fungi_fa_filtered+n_amf_fa_filtered)]

# 隣接行列の作成（相関係数が0.4以上）
adjacency_canopy_A_fa <- ifelse(fungal_amf_canopy_A_corr >= 0.6, 1, 0)
# グラフの作成
g_canopy_A_fa <- graph_from_incidence_matrix(adjacency_canopy_A_fa)

# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
fungi_asv_fa_A_names <- rownames(fungal_amf_canopy_A_corr)    # Fungal ASVs の行名
amf_asv_fa_A_names <- colnames(fungal_amf_canopy_A_corr) # amf ASVs の列名
# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_A_fa)$name <- c(fungi_asv_fa_A_names, amf_asv_fa_A_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_fa_A_class <- taxonomy_fungi_filtered[fungi_asv_fa_A_names, "Class"]
taxonomy_amf_fa_A_class <- taxonomy_amf_filtered[amf_asv_fa_A_names, "Class"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_fa_A_class)
unique_amf_classes <- unique(taxonomy_amf_fa_A_class)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_fungi_classes))  # "Set1" ベースの拡張パレット
palette_amf <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_amf_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_amf <- setNames(palette_amf, unique_amf_classes)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_fa_A_class]
node_colors_amf <- class_colors_amf[taxonomy_amf_fa_A_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_asv_fa_A_names))       # 真菌のノードの形
shapes_amf <- rep("square", length(amf_asv_fa_A_names))  # amfのノードの形
node_shapes <- c(shapes_fungi, shapes_amf)

# 8. エッジのないノードを削除
g_canopy_A_fa <- delete_vertices(g_canopy_A_fa, degree(g_canopy_A_fa) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_A_fa)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_asv_fa_A_names) {
    return(class_colors_fungi[taxonomy_fungi_fa_A_class[match(node_name, fungi_asv_fa_A_names)]])
  } else if (node_name %in% amf_asv_fa_A_names) {
    return(class_colors_amf[taxonomy_amf_fa_A_class[match(node_name, amf_asv_fa_A_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_asv_fa_A_names))
remaining_node_shapes_amf <- rep("square", sum(remaining_node_names %in% amf_asv_fa_A_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_A_fa)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_A_fa)

# 対数スケーリングでノードサイズを調整
V(g_canopy_A_fa)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_A_fa, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_A_fa)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("fungi_amf_class_TWINSPAN_A_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_amf_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_amf[unique_amf_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "AMF Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_A_fa)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_A_fa)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_TWINSPAN_A_f*a_0.6_ranking.csv", row.names = FALSE)

# taxonomy_bacteria_filteredの一番右の列(Speciesの列)を削除
#taxonomy_fungi_filtered_trimmed <- taxonomy_fungi_filtered[, -ncol(taxonomy_fungi_filtered)]
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_fungi_filtered, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_A_f*a_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

#####Module解析###############
# 二部グラフのプロジェクションを作成  
projection_result <- bipartite_projection(g_canopy_A_fa)
# プロジェクション結果を確認
fungi_projection <- projection_result$proj1  # 真菌側のプロジェクション
amf_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(fungi_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
fungi_clusters <- cluster_louvain(fungi_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
amf_clusters <- cluster_louvain(amf_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_A_fa)
# モジュール度（modularity）の計算
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_A_fa, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_A_fa)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_A_fa, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_A_fa, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_A_fa, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# 各指標の実行
edge_density_value <- edge_density(g_canopy_A_fa)
edge_count <- ecount(g_canopy_A_fa)
global_clustering <- transitivity(g_canopy_A_fa, type = "global")
degrees <- degree(g_canopy_A_fa)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

#### TWINASPAN B F*A ################################################################################
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_fa_filtered <- sum(colnames(combined_canopy_fa_table_filtered_B) %in% colnames(asv_fungi_canopy))
n_amf_fa_filtered <- sum(colnames(combined_canopy_fa_table_filtered_B) %in% colnames(asv_amf_canopy))

# これに基づいて、相関行列から正しいインデックスを取得
fungal_amf_canopy_B_corr <- correlation_canopy_fa_B_matrix[1:n_fungi_fa_filtered, (n_fungi_fa_filtered+1):(n_fungi_fa_filtered+n_amf_fa_filtered)]

# 隣接行列の作成（相関係数が0.4以上）
adjacency_canopy_B_fa <- ifelse(fungal_amf_canopy_B_corr >= 0.6, 1, 0)
# グラフの作成
g_canopy_B_fa <- graph_from_incidence_matrix(adjacency_canopy_B_fa)

# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
fungi_asv_fa_B_names <- rownames(fungal_amf_canopy_B_corr)    # Fungal ASVs の行名
amf_asv_fa_B_names <- colnames(fungal_amf_canopy_B_corr) # amf ASVs の列名
# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_B_fa)$name <- c(fungi_asv_fa_B_names, amf_asv_fa_B_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_fa_B_class <- taxonomy_fungi_filtered[fungi_asv_fa_B_names, "Class"]
taxonomy_amf_fa_B_class <- taxonomy_amf_filtered[amf_asv_fa_B_names, "Class"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_fa_B_class)
unique_amf_classes <- unique(taxonomy_amf_fa_B_class)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_fungi_classes))  # "Set1" ベースの拡張パレット
palette_amf <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_amf_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_amf <- setNames(palette_amf, unique_amf_classes)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_fa_B_class]
node_colors_amf <- class_colors_amf[taxonomy_amf_fa_B_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_asv_fa_B_names))       # 真菌のノードの形
shapes_amf <- rep("square", length(amf_asv_fa_B_names))  # amfのノードの形
node_shapes <- c(shapes_fungi, shapes_amf)

# 8. エッジのないノードを削除
g_canopy_B_fa <- delete_vertices(g_canopy_B_fa, degree(g_canopy_B_fa) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_B_fa)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_asv_fa_B_names) {
    return(class_colors_fungi[taxonomy_fungi_fa_B_class[match(node_name, fungi_asv_fa_B_names)]])
  } else if (node_name %in% amf_asv_fa_B_names) {
    return(class_colors_amf[taxonomy_amf_fa_B_class[match(node_name, amf_asv_fa_B_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_asv_fa_B_names))
remaining_node_shapes_amf <- rep("square", sum(remaining_node_names %in% amf_asv_fa_B_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_B_fa)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_B_fa)

# 対数スケーリングでノードサイズを調整
V(g_canopy_B_fa)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_B_fa, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_B_fa)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("fungi_amf_class_TWINSPAN_B_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_amf_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_amf[unique_amf_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "AMF Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_B_fa)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_B_fa)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_TWINSPAN_B_f*a_0.6_ranking.csv", row.names = FALSE)

# taxonomy_bacteria_filteredの一番右の列(Speciesの列)を削除
#taxonomy_fungi_filtered_trimmed <- taxonomy_fungi_filtered[, -ncol(taxonomy_fungi_filtered)]
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_fungi_filtered, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_B_f*a_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

#####Module解析###############
# 二部グラフのプロジェクションを作成  
projection_result <- bipartite_projection(g_canopy_B_fa)
# プロジェクション結果を確認
fungi_projection <- projection_result$proj1  # 真菌側のプロジェクション
amf_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(fungi_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
fungi_clusters <- cluster_louvain(fungi_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
amf_clusters <- cluster_louvain(amf_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_B_fa)
# モジュール度（modularity）の計算
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_B_fa, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_B_fa)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_B_fa, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_B_fa, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_B_fa, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# 各指標の実行
edge_density_value <- edge_density(g_canopy_B_fa)
edge_count <- ecount(g_canopy_B_fa)
global_clustering <- transitivity(g_canopy_B_fa, type = "global")
degrees <- degree(g_canopy_B_fa)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

#### TWINASPAN C F*A ################################################################################
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_fa_filtered <- sum(colnames(combined_canopy_fa_table_filtered_C) %in% colnames(asv_fungi_canopy))
n_amf_fa_filtered <- sum(colnames(combined_canopy_fa_table_filtered_C) %in% colnames(asv_amf_canopy))

# これに基づいて、相関行列から正しいインデックスを取得
fungal_amf_canopy_C_corr <- correlation_canopy_fa_C_matrix[1:n_fungi_fa_filtered, (n_fungi_fa_filtered+1):(n_fungi_fa_filtered+n_amf_fa_filtered)]

# 隣接行列の作成（相関係数が0.4以上）
adjacency_canopy_C_fa <- ifelse(fungal_amf_canopy_C_corr >= 0.6, 1, 0)
# グラフの作成
g_canopy_C_fa <- graph_from_incidence_matrix(adjacency_canopy_C_fa)

# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
fungi_asv_fa_C_names <- rownames(fungal_amf_canopy_C_corr)    # Fungal ASVs の行名
amf_asv_fa_C_names <- colnames(fungal_amf_canopy_C_corr) # amf ASVs の列名
# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_C_fa)$name <- c(fungi_asv_fa_C_names, amf_asv_fa_C_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_fa_C_class <- taxonomy_fungi_filtered[fungi_asv_fa_C_names, "Class"]
taxonomy_amf_fa_C_class <- taxonomy_amf_filtered[amf_asv_fa_C_names, "Class"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_fa_C_class)
unique_amf_classes <- unique(taxonomy_amf_fa_C_class)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_fungi_classes))  # "Set1" ベースの拡張パレット
palette_amf <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_amf_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_amf <- setNames(palette_amf, unique_amf_classes)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_fa_C_class]
node_colors_amf <- class_colors_amf[taxonomy_amf_fa_C_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_asv_fa_C_names))       # 真菌のノードの形
shapes_amf <- rep("square", length(amf_asv_fa_C_names))  # amfのノードの形
node_shapes <- c(shapes_fungi, shapes_amf)

# 8. エッジのないノードを削除
g_canopy_C_fa <- delete_vertices(g_canopy_C_fa, degree(g_canopy_C_fa) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_C_fa)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_asv_fa_C_names) {
    return(class_colors_fungi[taxonomy_fungi_fa_C_class[match(node_name, fungi_asv_fa_C_names)]])
  } else if (node_name %in% amf_asv_fa_C_names) {
    return(class_colors_amf[taxonomy_amf_fa_C_class[match(node_name, amf_asv_fa_C_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_asv_fa_C_names))
remaining_node_shapes_amf <- rep("square", sum(remaining_node_names %in% amf_asv_fa_C_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_C_fa)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_C_fa)

# 対数スケーリングでノードサイズを調整
V(g_canopy_C_fa)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_C_fa, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_C_fa)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("fungi_amf_class_TWINSPAN_C_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_amf_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_amf[unique_amf_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "AMF Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_C_fa)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_C_fa)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_TWINSPAN_C_f*a_0.6_ranking.csv", row.names = FALSE)

# taxonomy_bacteria_filteredの一番右の列(Speciesの列)を削除
#taxonomy_fungi_filtered_trimmed <- taxonomy_fungi_filtered[, -ncol(taxonomy_fungi_filtered)]
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_fungi_filtered, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_C_f*a_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

#####Module解析###############
# 二部グラフのプロジェクションを作成  
projection_result <- bipartite_projection(g_canopy_C_fa)
# プロジェクション結果を確認
fungi_projection <- projection_result$proj1  # 真菌側のプロジェクション
amf_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(fungi_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
fungi_clusters <- cluster_louvain(fungi_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
amf_clusters <- cluster_louvain(amf_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_C_fa)
# モジュール度（modularity）の計算
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_C_fa, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_C_fa)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_C_fa, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_C_fa, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_C_fa, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# 各指標の実行
edge_density_value <- edge_density(g_canopy_C_fa)
edge_count <- ecount(g_canopy_C_fa)
global_clustering <- transitivity(g_canopy_C_fa, type = "global")
degrees <- degree(g_canopy_C_fa)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

#### TWINASPAN D F*A ################################################################################
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_fa_filtered <- sum(colnames(combined_canopy_fa_table_filtered_D) %in% colnames(asv_fungi_canopy))
n_amf_fa_filtered <- sum(colnames(combined_canopy_fa_table_filtered_D) %in% colnames(asv_amf_canopy))

# これに基づいて、相関行列から正しいインデックスを取得
fungal_amf_canopy_D_corr <- correlation_canopy_fa_D_matrix[1:n_fungi_fa_filtered, (n_fungi_fa_filtered+1):(n_fungi_fa_filtered+n_amf_fa_filtered)]

# 隣接行列の作成（相関係数が0.4以上）
adjacency_canopy_D_fa <- ifelse(fungal_amf_canopy_D_corr >= 0.6, 1, 0)
# グラフの作成
g_canopy_D_fa <- graph_from_incidence_matrix(adjacency_canopy_D_fa)

# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
fungi_asv_fa_D_names <- rownames(fungal_amf_canopy_D_corr)    # Fungal ASVs の行名
amf_asv_fa_D_names <- colnames(fungal_amf_canopy_D_corr) # amf ASVs の列名
# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_D_fa)$name <- c(fungi_asv_fa_D_names, amf_asv_fa_D_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_fungi_fa_D_class <- taxonomy_fungi_filtered[fungi_asv_fa_D_names, "Class"]
taxonomy_amf_fa_D_class <- taxonomy_amf_filtered[amf_asv_fa_D_names, "Class"]

# 3. ユニークな 'class' を取得
unique_fungi_classes <- unique(taxonomy_fungi_fa_D_class)
unique_amf_classes <- unique(taxonomy_amf_fa_D_class)

# 4. 真菌には暖色系パレットを拡張
palette_fungi <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_fungi_classes))  # "Set1" ベースの拡張パレット
palette_amf <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_amf_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_fungi <- setNames(palette_fungi, unique_fungi_classes)
class_colors_amf <- setNames(palette_amf, unique_amf_classes)

# 6. ノードに色を割り当て
node_colors_fungi <- class_colors_fungi[taxonomy_fungi_fa_D_class]
node_colors_amf <- class_colors_amf[taxonomy_amf_fa_D_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_fungi, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_fungi <- rep("circle", length(fungi_asv_fa_D_names))       # 真菌のノードの形
shapes_amf <- rep("square", length(amf_asv_fa_D_names))  # amfのノードの形
node_shapes <- c(shapes_fungi, shapes_amf)

# 8. エッジのないノードを削除
g_canopy_D_fa <- delete_vertices(g_canopy_D_fa, degree(g_canopy_D_fa) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_D_fa)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% fungi_asv_fa_D_names) {
    return(class_colors_fungi[taxonomy_fungi_fa_D_class[match(node_name, fungi_asv_fa_D_names)]])
  } else if (node_name %in% amf_asv_fa_C_names) {
    return(class_colors_amf[taxonomy_amf_fa_D_class[match(node_name, amf_asv_fa_D_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_fungi <- rep("circle", sum(remaining_node_names %in% fungi_asv_fa_D_names))
remaining_node_shapes_amf <- rep("square", sum(remaining_node_names %in% amf_asv_fa_D_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_D_fa)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_D_fa)

# 対数スケーリングでノードサイズを調整
V(g_canopy_D_fa)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_D_fa, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_D_fa)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("fungi_amf_class_TWINSPAN_D_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_fungi_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_fungi[unique_fungi_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Fungi Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_amf_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_amf[unique_amf_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "AMF Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_D_fa)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_D_fa)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_TWINSPAN_D_f*a_0.6_ranking.csv", row.names = FALSE)

# taxonomy_bacteria_filteredの一番右の列(Speciesの列)を削除
#taxonomy_fungi_filtered_trimmed <- taxonomy_fungi_filtered[, -ncol(taxonomy_fungi_filtered)]
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_fungi_filtered, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_D_f*a_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

#####Module解析###############
# 二部グラフのプロジェクションを作成  
projection_result <- bipartite_projection(g_canopy_D_fa)
# プロジェクション結果を確認
fungi_projection <- projection_result$proj1  # 真菌側のプロジェクション
amf_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(fungi_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
fungi_clusters <- cluster_louvain(fungi_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
amf_clusters <- cluster_louvain(amf_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_D_fa)
# モジュール度（modularity）の計算
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_D_fa, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_D_fa)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_D_fa, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_D_fa, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_D_fa, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# 各指標の実行
edge_density_value <- edge_density(g_canopy_D_fa)
edge_count <- ecount(g_canopy_D_fa)
global_clustering <- transitivity(g_canopy_D_fa, type = "global")
degrees <- degree(g_canopy_D_fa)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

### 細菌＊AMF #############################################################################################################################
#####ground#######
#ground
# フィルタ後の真菌とバクテリアの列数を再定義
n_fungi_ground <- ncol(asv_fungi_ground)
n_bacteria_ground <- ncol(asv_bacteria_ground)
n_amf_ground <- ncol(asv_amf_ground)

# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_bacteria_ba_filtered <- sum(colnames(combined_ground_ba_table_filtered) %in% colnames(asv_bacteria_ground))
n_amf_ba_filtered <- sum(colnames(combined_ground_ba_table_filtered) %in% colnames(asv_amf_ground))

# これに基づいて、相関行列から正しいインデックスを取得
bacteria_amf_ground_corr <- correlation_ground_ba_matrix[1:n_bacteria_ba_filtered, (n_bacteria_ba_filtered + 1):ncol(correlation_ground_ba_matrix)]

# 隣接行列の作成（相関係数が0.4以上
adjacency_ground_ba <- ifelse(bacteria_amf_ground_corr >= 0.6, 1, 0)
# グラフの作成
g_ground_ba <- graph_from_incidence_matrix(adjacency_ground_ba)

# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
bacteria_asv_ground_names <- rownames(bacteria_amf_ground_corr)    # Fungal ASVs の行名
amf_asv_ground_names <- colnames(bacteria_amf_ground_corr) # Bacterial ASVs の列名

# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_ground_ba)$name <- c(bacteria_asv_ground_names, amf_asv_ground_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_bacteria_ground_class <- taxonomy_bacteria_filtered[bacteria_asv_ground_names, "Class"]
taxonomy_amf_ground_class <- taxonomy_amf_filtered[amf_asv_ground_names, "Class"]

# 3. ユニークな 'class' を取得
unique_bacteria_classes <- unique(taxonomy_bacteria_ground_class)
unique_amf_classes <- unique(taxonomy_amf_ground_class)

# 4. 真菌には暖色系パレットを拡張
palette_bacteria <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_bacteria_classes))  # "Set1" ベースの拡張パレット
palette_amf <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_amf_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)
class_colors_amf <- setNames(palette_amf, unique_amf_classes)

# 6. ノードに色を割り当て
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_ground_class]
node_colors_amf <- class_colors_amf[taxonomy_amf_ground_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_bacteria, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_bacteria <- rep("circle", length(bacteria_asv_ground_names))       # 真菌のノードの形
shapes_amf <- rep("square", length(amf_asv_ground_names))  # バクテリアのノードの形
node_shapes <- c(shapes_bacteria, shapes_amf)

# 8. エッジのないノードを削除
g_ground_ba <- delete_vertices(g_ground_ba, degree(g_ground_ba) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_ground_ba)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% bacteria_asv_ground_names) {
    return(class_colors_bacteria[taxonomy_bacteria_ground_class[match(node_name, bacteria_asv_ground_names)]])
  } else if (node_name %in% amf_asv_ground_names) {
    return(class_colors_amf[taxonomy_amf_ground_class[match(node_name, amf_asv_ground_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_bacteria <- rep("circle", sum(remaining_node_names %in% bacteria_asv_ground_names))
remaining_node_shapes_amf <- rep("square", sum(remaining_node_names %in% amf_asv_ground_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_ground_ba)

# 各ノードの次数を取得
node_degrees <- degree(g_ground_ba)

# ノードのサイズを平方根スケーリングで調整
V(g_ground_ba)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_ground_ba, 
     layout = layout,
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_ground_ba)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("bacteria_amf_class_ground_0.6_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_bacteria_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# amfの凡例を右上に配置
legend("topright", 
       legend = unique_amf_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_amf[unique_amf_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "AMF Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_ground_ba)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_ground_ba)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_ground_b*a_0.6_ranking.csv", row.names = FALSE)

# 元のデータフレームをコピー
taxonomy_bacteria_filtered_added <- taxonomy_bacteria_filtered
# 新しい列 "Species" を追加
taxonomy_bacteria_filtered_added$Species <- NA  # NAで初期化
# 結果を確認
print(head(taxonomy_bacteria_filtered_added))
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_bacteria_filtered_added, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_ground_b*a_0.6_ranking_with_taxonomy.csv", row.names = FALSE)


#####Module解析###############
# 二部グラフのプロジェクションを作成
projection_result <- bipartite_projection(g_ground_ba)
# プロジェクション結果を確認
bacteria_projection <- projection_result$proj1  # 真菌側のプロジェクション
amf_projection <- projection_result$proj2  # amf側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(bacteria_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
bacteria_clusters <- cluster_louvain(bacteria_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
amf_clusters <- cluster_louvain(amf_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_ground_ba)
# モジュール度（modularity）の計算
modularity_bacteria <- modularity(bacteria_clusters)
modularity_amf <- modularity(amf_clusters)
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_ground_ba, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_ground_ba)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示


#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
library(bipartite)
library(igraph)
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_ground_ba, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_ground_ba, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_ground_ba, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# ノード数とエッジ数を指定
num_nodes <- vcount(g_ground_ba)  # 真菌とバクテリアを合わせたノード数
num_edges <- ecount(g_ground_ba)  # エッジ数

# 指標を格納するためのベクトルを作成
random_connectance <- numeric(100)
random_nodf <- numeric(100)
random_modularity <- numeric(100)
random_h2 <- numeric(100)

set.seed(130)  # 再現性のためのシード設定

for (i in 1:100) {
  # ランダムなネットワークを生成（エッジ数を指定）
  random_graph <- erdos.renyi.game(num_nodes, num_edges, type = "gnm")
  
  # 隣接行列を取得
  adjacency_matrix <- as_adjacency_matrix(random_graph, sparse = FALSE)
  
  # ランダムネットワークの指標を計算
  random_connectance[i] <- networklevel(adjacency_matrix, index = "connectance")
  random_nodf[i] <- nested(adjacency_matrix, method = "NODF")
  random_modularity[i] <- modularity(cluster_louvain(random_graph))
  #random_h2[i] <- H2fun(adjacency_matrix, H2_integer = TRUE)$H2
}

# ランダムネットワークの平均と標準偏差を計算
mean_random_connectance <- mean(random_connectance)
sd_random_connectance <- sd(random_connectance)
mean_random_nodf <- mean(random_nodf)
sd_random_nodf <- sd(random_nodf)
mean_random_modularity <- mean(random_modularity)
sd_random_modularity <- sd(random_modularity)
#mean_random_h2 <- mean(random_h2)
#sd_random_h2 <- sd(random_h2)

# zスコアの計算
z_connectance <- (observed_connectance - mean_random_connectance) / sd_random_connectance
z_nodf <- (observed_nodf - mean_random_nodf) / sd_random_nodf
z_modularity <- (observed_modularity - mean_random_modularity) / sd_random_modularity
#z_h2 <- (observed_h2["H2"] - mean_random_h2) / sd_random_h2

# p値の計算（片側検定）
p_connectance <- 2 * (1 - pnorm(abs(z_connectance)))
p_nodf <- 2 * (1 - pnorm(abs(z_nodf)))
p_modularity <- 2 * (1 - pnorm(abs(z_modularity)))
#p_h2 <- 2 * (1 - pnorm(abs(z_h2)))

# 結果の表示
cat("Connectance: zスコア =", z_connectance, ", p値 =", format(p_connectance, scientific = TRUE), "\n")
cat("NODF: zスコア =", z_nodf, ", p値 =", format(p_nodf, scientific = TRUE), "\n")
cat("Modularity: zスコア =", z_modularity, ", p値 =", format(p_modularity, scientific = TRUE), "\n")
#cat("H2': zスコア =", z_h2, ", p値 =", p_h2, "\n")

# bipartite パッケージをアンロードする場合は！
detach("package:bipartite", unload = TRUE)

# sna パッケージをアンロードする場合は！
detach("package:sna", unload = TRUE)

# 各指標の実行
edge_density_value <- edge_density(g_ground_ba)
edge_count <- ecount(g_ground_ba)
global_clustering <- transitivity(g_ground_ba, type = "global")
degrees <- degree(g_ground_ba)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

###canopy####
# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_bacteria_ba_filtered <- sum(colnames(combined_canopy_ba_table_filtered) %in% colnames(asv_bacteria_canopy))
n_amf_ba_filtered <- sum(colnames(combined_canopy_ba_table_filtered) %in% colnames(asv_amf_canopy))

# これに基づいて、相関行列から正しいインデックスを取得
bacteria_amf_canopy_corr <- correlation_canopy_ba_matrix[1:n_bacteria_ba_filtered, (n_bacteria_ba_filtered + 1):ncol(correlation_canopy_ba_matrix)]

# 隣接行列の作成（相関係数が0.4以上
adjacency_canopy_ba <- ifelse(bacteria_amf_canopy_corr >= 0.6, 1, 0)
# グラフの作成
g_canopy_ba <- graph_from_incidence_matrix(adjacency_canopy_ba)

# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
bacteria_asv_canopy_names <- rownames(bacteria_amf_canopy_corr)    # Fungal ASVs の行名
amf_asv_canopy_names <- colnames(bacteria_amf_canopy_corr) # Bacterial ASVs の列名

# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_ba)$name <- c(bacteria_asv_canopy_names, amf_asv_canopy_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_bacteria_canopy_class <- taxonomy_bacteria_filtered[rownames(bacteria_amf_canopy_corr), "Class"]
taxonomy_amf_canopy_class <- taxonomy_amf_filtered[colnames(bacteria_amf_canopy_corr), "Class"]

# 3. ユニークな 'class' を取得
unique_bacteria_classes <- unique(taxonomy_bacteria_canopy_class)
unique_amf_classes <- unique(taxonomy_amf_canopy_class)

# 4. 真菌には暖色系パレットを拡張
palette_bacteria <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_bacteria_classes))  # "Set1" ベースの拡張パレット
palette_amf <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_amf_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)
class_colors_amf <- setNames(palette_amf, unique_amf_classes)

# 6. ノードに色を割り当て
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_canopy_class]
node_colors_amf <- class_colors_amf[taxonomy_amf_canopy_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_bacteria, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_bacteria <- rep("circle", length(bacteria_asv_canopy_names))       # 真菌のノードの形
shapes_amf <- rep("square", length(amf_asv_canopy_names))  # バクテリアのノードの形
node_shapes <- c(shapes_bacteria, shapes_amf)

# 8. エッジのないノードを削除
g_canopy_ba <- delete_vertices(g_canopy_ba, degree(g_canopy_ba) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_ba)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% bacteria_asv_canopy_names) {
    return(class_colors_bacteria[taxonomy_bacteria_canopy_class[match(node_name, bacteria_asv_canopy_names)]])
  } else if (node_name %in% amf_asv_canopy_names) {
    return(class_colors_amf[taxonomy_amf_canopy_class[match(node_name, amf_asv_canopy_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_bacteria <- rep("circle", sum(remaining_node_names %in% bacteria_asv_canopy_names))
remaining_node_shapes_amf <- rep("square", sum(remaining_node_names %in% amf_asv_canopy_names))
remaining_node_shapes <- c(remaining_node_shapes_fungi, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_ba)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_ba)

# ノードのサイズを平方根スケーリングで調整
V(g_canopy_ba)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_ba, 
     layout = layout,
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_ba)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("bacteria_amf_class_canopy_0.6_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_bacteria_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# amfの凡例を右上に配置
legend("topright", 
       legend = unique_amf_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_amf[unique_amf_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "AMF Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_ba)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_ba)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_canopy_b*a_0.6_ranking.csv", row.names = FALSE)

# 元のデータフレームをコピー
taxonomy_bacteria_filtered_added <- taxonomy_bacteria_filtered
# 新しい列 "Species" を追加
taxonomy_bacteria_filtered_added$Species <- NA  # NAで初期化
# 結果を確認
print(head(taxonomy_bacteria_filtered_added))
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_bacteria_filtered_added, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合

# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_canopy_b*a_0.6_ranking_with_taxonomy.csv", row.names = FALSE)


#####Module解析###############
# 二部グラフのプロジェクションを作成
projection_result <- bipartite_projection(g_canopy_ba)
# プロジェクション結果を確認
bacteria_projection <- projection_result$proj1  # 真菌側のプロジェクション
amf_projection <- projection_result$proj2  # amf側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(bacteria_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
bacteria_clusters <- cluster_louvain(bacteria_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
amf_clusters <- cluster_louvain(amf_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_ba)
# モジュール度（modularity）の計算
modularity_bacteria <- modularity(bacteria_clusters)
modularity_amf <- modularity(amf_clusters)
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_ba, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_ba)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示


#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
library(bipartite)
library(igraph)
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_ba, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_ba, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_ba, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# ノード数とエッジ数を指定
num_nodes <- vcount(g_canopy_ba)  # 真菌とバクテリアを合わせたノード数
num_edges <- ecount(g_canopy_ba)  # エッジ数

# 指標を格納するためのベクトルを作成
random_connectance <- numeric(100)
random_nodf <- numeric(100)
random_modularity <- numeric(100)
random_h2 <- numeric(100)

set.seed(130)  # 再現性のためのシード設定

for (i in 1:100) {
  # ランダムなネットワークを生成（エッジ数を指定）
  random_graph <- erdos.renyi.game(num_nodes, num_edges, type = "gnm")
  
  # 隣接行列を取得
  adjacency_matrix <- as_adjacency_matrix(random_graph, sparse = FALSE)
  
  # ランダムネットワークの指標を計算
  random_connectance[i] <- networklevel(adjacency_matrix, index = "connectance")
  random_nodf[i] <- nested(adjacency_matrix, method = "NODF")
  random_modularity[i] <- modularity(cluster_louvain(random_graph))
  #random_h2[i] <- H2fun(adjacency_matrix, H2_integer = TRUE)$H2
}

# ランダムネットワークの平均と標準偏差を計算
mean_random_connectance <- mean(random_connectance)
sd_random_connectance <- sd(random_connectance)
mean_random_nodf <- mean(random_nodf)
sd_random_nodf <- sd(random_nodf)
mean_random_modularity <- mean(random_modularity)
sd_random_modularity <- sd(random_modularity)
#mean_random_h2 <- mean(random_h2)
#sd_random_h2 <- sd(random_h2)

# zスコアの計算
z_connectance <- (observed_connectance - mean_random_connectance) / sd_random_connectance
z_nodf <- (observed_nodf - mean_random_nodf) / sd_random_nodf
z_modularity <- (observed_modularity - mean_random_modularity) / sd_random_modularity
#z_h2 <- (observed_h2["H2"] - mean_random_h2) / sd_random_h2

# p値の計算（片側検定）
p_connectance <- 2 * (1 - pnorm(abs(z_connectance)))
p_nodf <- 2 * (1 - pnorm(abs(z_nodf)))
p_modularity <- 2 * (1 - pnorm(abs(z_modularity)))
#p_h2 <- 2 * (1 - pnorm(abs(z_h2)))

# 結果の表示
cat("Connectance: zスコア =", z_connectance, ", p値 =", format(p_connectance, scientific = TRUE), "\n")
cat("NODF: zスコア =", z_nodf, ", p値 =", format(p_nodf, scientific = TRUE), "\n")
cat("Modularity: zスコア =", z_modularity, ", p値 =", format(p_modularity, scientific = TRUE), "\n")
#cat("H2': zスコア =", z_h2, ", p値 =", p_h2, "\n")

# bipartite パッケージをアンロードする場合は！
detach("package:bipartite", unload = TRUE)

# sna パッケージをアンロードする場合は！
detach("package:sna", unload = TRUE)

# 各指標の実行
edge_density_value <- edge_density(g_canopy_ba)
edge_count <- ecount(g_canopy_ba)
global_clustering <- transitivity(g_canopy_ba, type = "global")
degrees <- degree(g_canopy_ba)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

#### TWINASPAN A B*A ################################################################################

# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_bacteria_ba_filtered <- sum(colnames(combined_canopy_ba_table_filtered_A) %in% colnames(asv_bacteria_canopy))
n_amf_ba_filtered <- sum(colnames(combined_canopy_ba_table_filtered_A) %in% colnames(asv_amf_canopy))

# これに基づいて、相関行列から正しいインデックスを取得
bacteria_amf_canopy_A_corr <- correlation_canopy_ba_A_matrix[1:n_bacteria_ba_filtered, (n_bacteria_ba_filtered+1):(n_bacteria_ba_filtered+n_amf_ba_filtered)]

# 隣接行列の作成（相関係数が0.4以上）
adjacency_canopy_A_ba <- ifelse(bacteria_amf_canopy_A_corr >= 0.6, 1, 0)
# グラフの作成
g_canopy_A_ba <- graph_from_incidence_matrix(adjacency_canopy_A_ba)

# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
bacteria_asv_ba_A_names <- rownames(bacteria_amf_canopy_A_corr)    # Fungal ASVs の行名
amf_asv_ba_A_names <- colnames(bacteria_amf_canopy_A_corr) # amf ASVs の列名
# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_A_ba)$name <- c(bacteria_asv_ba_A_names, amf_asv_ba_A_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_bacteria_ba_A_class <- taxonomy_bacteria_filtered[bacteria_asv_ba_A_names, "Class"]
taxonomy_amf_ba_A_class <- taxonomy_amf_filtered[amf_asv_ba_A_names, "Class"]

# 3. ユニークな 'class' を取得
unique_bacteria_classes <- unique(taxonomy_bacteria_ba_A_class)
unique_amf_classes <- unique(taxonomy_amf_ba_A_class)

# 4. 真菌には暖色系パレットを拡張
palette_bacteria <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_bacteria_classes))  # "Set1" ベースの拡張パレット
palette_amf <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_amf_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)
class_colors_amf <- setNames(palette_amf, unique_amf_classes)

# 6. ノードに色を割り当て
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_ba_A_class]
node_colors_amf <- class_colors_amf[taxonomy_amf_ba_A_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_bacteria, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_bacteria <- rep("circle", length(bacteria_asv_ba_A_names))       # 真菌のノードの形
shapes_amf <- rep("square", length(amf_asv_ba_A_names))  # amfのノードの形
node_shapes <- c(shapes_bacteria, shapes_amf)

# 8. エッジのないノードを削除
g_canopy_A_ba <- delete_vertices(g_canopy_A_ba, degree(g_canopy_A_ba) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_A_ba)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% bacteria_asv_ba_A_names) {
    return(class_colors_bacteria[taxonomy_bacteria_ba_A_class[match(node_name, bacteria_asv_ba_A_names)]])
  } else if (node_name %in% amf_asv_ba_A_names) {
    return(class_colors_amf[taxonomy_amf_ba_A_class[match(node_name, amf_asv_ba_A_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_bacteria <- rep("circle", sum(remaining_node_names %in% bacteria_asv_ba_A_names))
remaining_node_shapes_amf <- rep("square", sum(remaining_node_names %in% amf_asv_ba_A_names))
remaining_node_shapes <- c(remaining_node_shapes_bacteria, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_A_ba)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_A_ba)

# 対数スケーリングでノードサイズを調整
V(g_canopy_A_ba)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_A_ba, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_A_ba)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("bacteria_amf_class_TWINSPAN_A_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_bacteria_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_amf_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_amf[unique_amf_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "AMF Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_A_ba)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_A_ba)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_TWINSPAN_A_b*a_0.6_ranking.csv", row.names = FALSE)

# taxonomy_bacteria_filteredの一番右の列にSpeciesの列)を追加
# 元のデータフレームをコピー
taxonomy_bacteria_filtered_added <- taxonomy_bacteria_filtered
# 新しい列 "Species" を追加
taxonomy_bacteria_filtered_added$Species <- NA  # NAで初期化
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_bacteria_filtered_added, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_A_b*a_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

#####Module解析###############
# 二部グラフのプロジェクションを作成  
projection_result <- bipartite_projection(g_canopy_A_ba)
# プロジェクション結果を確認
bacteria_projection <- projection_result$proj1  # 真菌側のプロジェクション
amf_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(bacteria_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
bacteria_clusters <- cluster_louvain(bacteria_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
amf_clusters <- cluster_louvain(amf_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_A_ba)
# モジュール度（modularity）の計算
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_A_ba, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_A_ba)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_A_ba, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_A_ba, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_A_ba, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# 各指標の実行
edge_density_value <- edge_density(g_canopy_A_ba)
edge_count <- ecount(g_canopy_A_ba)
global_clustering <- transitivity(g_canopy_A_ba, type = "global")
degrees <- degree(g_canopy_A_ba)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

#### TWINASPAN B B*A ################################################################################

# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_bacteria_ba_filtered <- sum(colnames(combined_canopy_ba_table_filtered_B) %in% colnames(asv_bacteria_canopy))
n_amf_ba_filtered <- sum(colnames(combined_canopy_ba_table_filtered_B) %in% colnames(asv_amf_canopy))

# これに基づいて、相関行列から正しいインデックスを取得
bacteria_amf_canopy_B_corr <- correlation_canopy_ba_B_matrix[1:n_bacteria_ba_filtered, (n_bacteria_ba_filtered+1):(n_bacteria_ba_filtered+n_amf_ba_filtered)]

# 隣接行列の作成（相関係数が0.4以上）
adjacency_canopy_B_ba <- ifelse(bacteria_amf_canopy_B_corr >= 0.6, 1, 0)
# グラフの作成
g_canopy_B_ba <- graph_from_incidence_matrix(adjacency_canopy_B_ba)

# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
bacteria_asv_ba_B_names <- rownames(bacteria_amf_canopy_B_corr)    # Fungal ASVs の行名
amf_asv_ba_B_names <- colnames(bacteria_amf_canopy_B_corr) # amf ASVs の列名
# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_B_ba)$name <- c(bacteria_asv_ba_B_names, amf_asv_ba_B_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_bacteria_ba_B_class <- taxonomy_bacteria_filtered[bacteria_asv_ba_B_names, "Class"]
taxonomy_amf_ba_B_class <- taxonomy_amf_filtered[amf_asv_ba_B_names, "Class"]

# 3. ユニークな 'class' を取得
unique_bacteria_classes <- unique(taxonomy_bacteria_ba_B_class)
unique_amf_classes <- unique(taxonomy_amf_ba_B_class)

# 4. 真菌には暖色系パレットを拡張
palette_bacteria <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_bacteria_classes))  # "Set1" ベースの拡張パレット
palette_amf <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_amf_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)
class_colors_amf <- setNames(palette_amf, unique_amf_classes)

# 6. ノードに色を割り当て
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_ba_B_class]
node_colors_amf <- class_colors_amf[taxonomy_amf_ba_B_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_bacteria, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_bacteria <- rep("circle", length(bacteria_asv_ba_B_names))       # 真菌のノードの形
shapes_amf <- rep("square", length(amf_asv_ba_B_names))  # amfのノードの形
node_shapes <- c(shapes_bacteria, shapes_amf)

# 8. エッジのないノードを削除
g_canopy_B_ba <- delete_vertices(g_canopy_B_ba, degree(g_canopy_B_ba) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_B_ba)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% bacteria_asv_ba_B_names) {
    return(class_colors_bacteria[taxonomy_bacteria_ba_B_class[match(node_name, bacteria_asv_ba_B_names)]])
  } else if (node_name %in% amf_asv_ba_B_names) {
    return(class_colors_amf[taxonomy_amf_ba_B_class[match(node_name, amf_asv_ba_B_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_bacteria <- rep("circle", sum(remaining_node_names %in% bacteria_asv_ba_B_names))
remaining_node_shapes_amf <- rep("square", sum(remaining_node_names %in% amf_asv_ba_B_names))
remaining_node_shapes <- c(remaining_node_shapes_bacteria, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_B_ba)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_B_ba)

# 対数スケーリングでノードサイズを調整
V(g_canopy_B_ba)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_B_ba, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_B_ba)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("bacteria_amf_class_TWINSPAN_B_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_bacteria_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_amf_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_amf[unique_amf_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "AMF Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_B_ba)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_B_ba)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_TWINSPAN_B_b*a_0.6_ranking.csv", row.names = FALSE)

# taxonomy_bacteria_filteredの一番右の列にSpeciesの列)を追加
# 元のデータフレームをコピー
taxonomy_bacteria_filtered_added <- taxonomy_bacteria_filtered
# 新しい列 "Species" を追加
taxonomy_bacteria_filtered_added$Species <- NA  # NAで初期化
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_bacteria_filtered_added, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_B_b*a_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

#####Module解析###############
# 二部グラフのプロジェクションを作成  
projection_result <- bipartite_projection(g_canopy_B_ba)
# プロジェクション結果を確認
bacteria_projection <- projection_result$proj1  # 真菌側のプロジェクション
amf_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(bacteria_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
bacteria_clusters <- cluster_louvain(bacteria_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
amf_clusters <- cluster_louvain(amf_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_B_ba)
# モジュール度（modularity）の計算
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_B_ba, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_B_ba)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_B_ba, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_B_ba, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_B_ba, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# 各指標の実行
edge_density_value <- edge_density(g_canopy_B_ba)
edge_count <- ecount(g_canopy_B_ba)
global_clustering <- transitivity(g_canopy_B_ba, type = "global")
degrees <- degree(g_canopy_B_ba)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

#### TWINASPAN C B*A ################################################################################

# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_bacteria_ba_filtered <- sum(colnames(combined_canopy_ba_table_filtered_C) %in% colnames(asv_bacteria_canopy))
n_amf_ba_filtered <- sum(colnames(combined_canopy_ba_table_filtered_C) %in% colnames(asv_amf_canopy))

# これに基づいて、相関行列から正しいインデックスを取得
bacteria_amf_canopy_C_corr <- correlation_canopy_ba_C_matrix[1:n_bacteria_ba_filtered, (n_bacteria_ba_filtered+1):(n_bacteria_ba_filtered+n_amf_ba_filtered)]

# 隣接行列の作成（相関係数が0.4以上）
adjacency_canopy_C_ba <- ifelse(bacteria_amf_canopy_C_corr >= 0.6, 1, 0)
# グラフの作成
g_canopy_C_ba <- graph_from_incidence_matrix(adjacency_canopy_C_ba)

# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
bacteria_asv_ba_C_names <- rownames(bacteria_amf_canopy_C_corr)    # Fungal ASVs の行名
amf_asv_ba_C_names <- colnames(bacteria_amf_canopy_C_corr) # amf ASVs の列名
# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_C_ba)$name <- c(bacteria_asv_ba_C_names, amf_asv_ba_C_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_bacteria_ba_C_class <- taxonomy_bacteria_filtered[bacteria_asv_ba_C_names, "Class"]
taxonomy_amf_ba_C_class <- taxonomy_amf_filtered[amf_asv_ba_C_names, "Class"]

# 3. ユニークな 'class' を取得
unique_bacteria_classes <- unique(taxonomy_bacteria_ba_C_class)
unique_amf_classes <- unique(taxonomy_amf_ba_C_class)

# 4. 真菌には暖色系パレットを拡張
palette_bacteria <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_bacteria_classes))  # "Set1" ベースの拡張パレット
palette_amf <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_amf_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)
class_colors_amf <- setNames(palette_amf, unique_amf_classes)

# 6. ノードに色を割り当て
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_ba_C_class]
node_colors_amf <- class_colors_amf[taxonomy_amf_ba_C_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_bacteria, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_bacteria <- rep("circle", length(bacteria_asv_ba_C_names))       # 真菌のノードの形
shapes_amf <- rep("square", length(amf_asv_ba_C_names))  # amfのノードの形
node_shapes <- c(shapes_bacteria, shapes_amf)

# 8. エッジのないノードを削除
g_canopy_C_ba <- delete_vertices(g_canopy_C_ba, degree(g_canopy_C_ba) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_C_ba)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% bacteria_asv_ba_C_names) {
    return(class_colors_bacteria[taxonomy_bacteria_ba_C_class[match(node_name, bacteria_asv_ba_C_names)]])
  } else if (node_name %in% amf_asv_ba_C_names) {
    return(class_colors_amf[taxonomy_amf_ba_C_class[match(node_name, amf_asv_ba_C_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_bacteria <- rep("circle", sum(remaining_node_names %in% bacteria_asv_ba_C_names))
remaining_node_shapes_amf <- rep("square", sum(remaining_node_names %in% amf_asv_ba_C_names))
remaining_node_shapes <- c(remaining_node_shapes_bacteria, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_C_ba)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_C_ba)

# 対数スケーリングでノードサイズを調整
V(g_canopy_C_ba)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_C_ba, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_C_ba)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("bacteria_amf_class_TWINSPAN_C_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_bacteria_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_amf_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_amf[unique_amf_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "AMF Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_C_ba)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_C_ba)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_TWINSPAN_C_b*a_0.6_ranking.csv", row.names = FALSE)

# taxonomy_bacteria_filteredの一番右の列にSpeciesの列)を追加
# 元のデータフレームをコピー
taxonomy_bacteria_filtered_added <- taxonomy_bacteria_filtered
# 新しい列 "Species" を追加
taxonomy_bacteria_filtered_added$Species <- NA  # NAで初期化
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_bacteria_filtered_added, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_C_b*a_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

#####Module解析###############
# 二部グラフのプロジェクションを作成  
projection_result <- bipartite_projection(g_canopy_C_ba)
# プロジェクション結果を確認
bacteria_projection <- projection_result$proj1  # 真菌側のプロジェクション
amf_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(bacteria_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
bacteria_clusters <- cluster_louvain(bacteria_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
amf_clusters <- cluster_louvain(amf_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_C_ba)
# モジュール度（modularity）の計算
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_C_ba, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_C_ba)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_C_ba, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_C_ba, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_C_ba, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# 各指標の実行
edge_density_value <- edge_density(g_canopy_C_ba)
edge_count <- ecount(g_canopy_C_ba)
global_clustering <- transitivity(g_canopy_C_ba, type = "global")
degrees <- degree(g_canopy_C_ba)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

#### TWINASPAN D B*A ################################################################################

# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_bacteria_ba_filtered <- sum(colnames(combined_canopy_ba_table_filtered_D) %in% colnames(asv_bacteria_canopy))
n_amf_ba_filtered <- sum(colnames(combined_canopy_ba_table_filtered_D) %in% colnames(asv_amf_canopy))

# これに基づいて、相関行列から正しいインデックスを取得
bacteria_amf_canopy_D_corr <- correlation_canopy_ba_D_matrix[1:n_bacteria_ba_filtered, (n_bacteria_ba_filtered+1):(n_bacteria_ba_filtered+n_amf_ba_filtered)]

# 隣接行列の作成（相関係数が0.4以上）
adjacency_canopy_D_ba <- ifelse(bacteria_amf_canopy_D_corr >= 0.6, 1, 0)
# グラフの作成
g_canopy_D_ba <- graph_from_incidence_matrix(adjacency_canopy_D_ba)

# 1. 行名（fungal ASVs）と列名（bacterial ASVs）を取得
bacteria_asv_ba_D_names <- rownames(bacteria_amf_canopy_D_corr)    # Fungal ASVs の行名
amf_asv_ba_D_names <- colnames(bacteria_amf_canopy_D_corr) # amf ASVs の列名
# 2. ノード名の設定 (行名と列名を結合して設定)
V(g_canopy_D_ba)$name <- c(bacteria_asv_ba_D_names, amf_asv_ba_D_names)

# 2. fungiの'class' 情報を抽出,Bacterial ASVsの 'class' 情報を取得
taxonomy_bacteria_ba_D_class <- taxonomy_bacteria_filtered[bacteria_asv_ba_D_names, "Class"]
taxonomy_amf_ba_D_class <- taxonomy_amf_filtered[amf_asv_ba_D_names, "Class"]

# 3. ユニークな 'class' を取得
unique_bacteria_classes <- unique(taxonomy_bacteria_ba_D_class)
unique_amf_classes <- unique(taxonomy_amf_ba_D_class)

# 4. 真菌には暖色系パレットを拡張
palette_bacteria <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_bacteria_classes))  # "Set1" ベースの拡張パレット
palette_amf <- colorRampPalette(brewer.pal(9, "Set3"))(length(unique_amf_classes))  # "Set3" ベースの拡張パレット

# 5. 'class' ごとに色を割り当て
class_colors_bacteria <- setNames(palette_bacteria, unique_bacteria_classes)
class_colors_amf <- setNames(palette_amf, unique_amf_classes)

# 6. ノードに色を割り当て
node_colors_bacteria <- class_colors_bacteria[taxonomy_bacteria_ba_D_class]
node_colors_amf <- class_colors_amf[taxonomy_amf_ba_D_class]

# 6.5. Fungal ASVsとBacterial ASVsの色を結合
node_colors <- c(node_colors_bacteria, node_colors_amf)

# 7. ノードの形を設定（真菌は丸、バクテリアは三角）
shapes_bacteria <- rep("circle", length(bacteria_asv_ba_D_names))       # 真菌のノードの形
shapes_amf <- rep("square", length(amf_asv_ba_D_names))  # amfのノードの形
node_shapes <- c(shapes_bacteria, shapes_amf)

# 8. エッジのないノードを削除
g_canopy_D_ba <- delete_vertices(g_canopy_D_ba, degree(g_canopy_D_ba) == 0)

# 9. 削除後のノード名を取得
remaining_node_names <- V(g_canopy_D_ba)$name
# 10. 残ったノードに対応する色と形を再設定
remaining_node_colors <- sapply(remaining_node_names, function(node_name) {
  if (node_name %in% bacteria_asv_ba_D_names) {
    return(class_colors_bacteria[taxonomy_bacteria_ba_D_class[match(node_name, bacteria_asv_ba_D_names)]])
  } else if (node_name %in% amf_asv_ba_D_names) {
    return(class_colors_amf[taxonomy_amf_ba_D_class[match(node_name, amf_asv_ba_D_names)]])
  } else {
    return(NA)  # 該当しない場合はNA
  }
})

# 11. 残ったノードの形を設定
remaining_node_shapes_bacteria <- rep("circle", sum(remaining_node_names %in% bacteria_asv_ba_D_names))
remaining_node_shapes_amf <- rep("square", sum(remaining_node_names %in% amf_asv_ba_D_names))
remaining_node_shapes <- c(remaining_node_shapes_bacteria, remaining_node_shapes_amf)

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_D_ba)

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_D_ba)

# 対数スケーリングでノードサイズを調整
V(g_canopy_D_ba)$size <- log(node_degrees + 1) * 3  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# 12. 削除後のノードに色と形を反映させたネットワーク図を描画
plot(g_canopy_D_ba, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(remaining_node_colors, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_D_ba)$size,  # ノードのサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を設定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# PNG画像として凡例を保存
png("bacteria_amf_class_TWINSPAN_D_legend.png", width = 800, height = 600)

# 新しいプロット領域を開く
plot.new()

# 真菌の凡例を左上に配置
legend("topleft", 
       legend = unique_bacteria_classes,  # 真菌のカテゴリ名
       fill = adjustcolor(class_colors_bacteria[unique_bacteria_classes], alpha.f = 0.7),  # 真菌の対応する色
       title = "Bacteria Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# バクテリアの凡例を右上に配置
legend("topright", 
       legend = unique_amf_classes,  # バクテリアのカテゴリ名
       fill = adjustcolor(class_colors_amf[unique_amf_classes], alpha.f = 0.7),  # バクテリアの対応する色
       title = "AMF Class",  # 凡例のタイトル
       border = "black",  # 凡例枠線の色
       bty = "n",  # ボックスなし
       cex = 1.5,  # 文字サイズを大きく
       pt.cex = 2)  # シンボル（塗りつぶし）のサイズを大きく

# 画像出力を終了
dev.off()

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_D_ba)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_D_ba)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_TWINSPAN_D_b*a_0.6_ranking.csv", row.names = FALSE)

# taxonomy_bacteria_filteredの一番右の列にSpeciesの列)を追加
# 元のデータフレームをコピー
taxonomy_bacteria_filtered_added <- taxonomy_bacteria_filtered
# 新しい列 "Species" を追加
taxonomy_bacteria_filtered_added$Species <- NA  # NAで初期化
# タクソノミー情報を結合
taxonomy_combined <- rbind(taxonomy_bacteria_filtered_added, taxonomy_amf_filtered)
# taxonomy_combinedに行名をASV列として追加
taxonomy_combined_with_asv <- taxonomy_combined %>%
  rownames_to_column(var = "ASV")
# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_D_b*a_0.6_ranking_with_taxonomy.csv", row.names = FALSE)

#####Module解析###############
# 二部グラフのプロジェクションを作成  
projection_result <- bipartite_projection(g_canopy_D_ba)
# プロジェクション結果を確認
bacteria_projection <- projection_result$proj1  # 真菌側のプロジェクション
amf_projection <- projection_result$proj2  # バクテリア側のプロジェクション
# プロジェクションが正しく作成されたか確認
print(class(bacteria_projection))  # "igraph" が返ってくるか確認
# Louvain法によるモジュール検出（真菌プロジェクション）
bacteria_clusters <- cluster_louvain(bacteria_projection)
# Louvain法によるモジュール検出（バクテリアプロジェクション）
amf_clusters <- cluster_louvain(amf_projection)
# 二部グラフ全体に対してLouvain法を適用する
bipartite_clusters <- cluster_louvain(g_canopy_D_ba)
# モジュール度（modularity）の計算
modularity_bipartite <- modularity(bipartite_clusters)

# 結果を表示
print(modularity_bipartite)

# グラフのプロット（コミュニティごとの色分けも加える）
plot(g_canopy_D_ba, 
     layout = layout,  # レイアウト指定
     vertex.color = membership(bipartite_clusters),  # コミュニティごとの色分け
     vertex.size = V(g_canopy_D_ba)$size,  # ノードサイズ
     vertex.shape = remaining_node_shapes,  # ノードの形を指定
     edge.width = 2,  # エッジの太さ
     vertex.label = NA)  # ノードラベルは非表示

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_D_ba, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_D_ba, method = "NODF")
print(weighted_nodf)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_D_ba, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

# 各指標の実行
edge_density_value <- edge_density(g_canopy_D_ba)
edge_count <- ecount(g_canopy_D_ba)
global_clustering <- transitivity(g_canopy_D_ba, type = "global")
degrees <- degree(g_canopy_D_ba)
max_degree <- max(degrees)
mean_degree <- mean(degrees)
num_high_degree_nodes <- sum(degrees >= 10)

cat("エッジ密度:", edge_density_value, "\n")
cat("エッジ数:", edge_count, "\n")
cat("グローバルクラスタリング係数:", global_clustering, "\n")
cat("最大degree数:", max_degree, "\n")
cat("平均degree数:", mean_degree, "\n")
cat("エッジ数10以上のノード数:", num_high_degree_nodes, "\n")

### fungi 同士の相関行列を抽出#############################################################################################################################################
####ground
# フィルタ後の真菌とバクテリアの列数を再定義
n_fungi_ground <- ncol(asv_fungi_ground)
n_bacteria_ground <- ncol(asv_bacteria_ground)

# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_ground_table_filtered) %in% colnames(asv_fungi_ground))
n_bacteria_filtered <- sum(colnames(combined_ground_table_filtered) %in% colnames(asv_bacteria_ground))

fungi_ground_only_corr <- combined_ground_table_filtered[1:n_fungi_filtered, 1:n_fungi_filtered]
fungi_ground_only_corr <- fungi_ground_only_corr[1:24, ]

# 各列の標準偏差を計算
sd_values <- apply(fungi_ground_only_corr, 2, sd)
# 標準偏差がゼロの列を確認
zero_sd_cols <- which(sd_values == 0)
print(zero_sd_cols)  # 標準偏差がゼロの列番号を確認
# 標準偏差がゼロでない列を残す
fungi_ground_filtered <- fungi_ground_only_corr[, sd_values > 0]
# Spearman相関行列を計算
correlation_fungi_ground_matrix <- cor(fungi_ground_filtered, method = "spearman")
# 対角成分（自己相関）は 0 にする
diag(correlation_fungi_ground_matrix) <- 0

# 閾値を設定して相関係数をフィルタリング（0.4以上の相関のみ残す）
adjacency_ground_ff <- ifelse(correlation_fungi_ground_matrix >= 0.6, correlation_fungi_ground_matrix*5, 0)

# ASVに基づく重み付きグラフを作成
g_ground_ff <- graph_from_adjacency_matrix(adjacency_ground_ff, mode = "undirected", weighted = TRUE, diag = FALSE)
# エッジのないノードを削除
g_ground_ff <- delete_vertices(g_ground_ff, degree(g_ground_ff) == 0)
V(g_ground_ff)$name
# 削除後に残ったノード（ASV）名を確認
remaining_asvs <- V(g_ground_ff)$name
print(remaining_asvs)

# 'remaining_asvs' に基づいて taxonomy_fungi_filtered から対応するタクソノミー情報を抽出
remaining_taxonomy_fungi <- taxonomy_fungi_filtered[rownames(taxonomy_fungi_filtered) %in% remaining_asvs, ]
# 'Class' 情報を抽出
taxonomy_fungi_ground_class <- remaining_taxonomy_fungi[, "Class"]

# ユニークなクラスごとに色を設定（暖色系のパレット "Set1" を使用）
unique_classes <- unique(taxonomy_fungi_ground_class)
palette <- brewer.pal(min(length(unique_classes), 9), "Set1")  # "Set1" の色を取得（最大9色まで）
if (length(unique_classes) > 9) {
  palette <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_classes))  # 9色以上の場合に拡張
}
class_colors <- setNames(palette, unique_classes)

# クラスに基づいてノードに色を割り当てる
node_colors <- class_colors[taxonomy_fungi_ground_class]
V(g_ground_ff)$color <- node_colors

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_ground_ff)

# 各ノードの次数を取得
node_degrees <- degree(g_ground_ff)

# ノードのサイズを次数に比例させる
V(g_ground_ff)$size <- log(node_degrees + 1) * 5  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# ノードの透明度を高め、サイズを小さくしてネットワーク図を描画
plot(g_ground_ff, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(V(g_ground_ff)$color, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_ground_ff)$size,  # ノードのサイズを次数に比例させる
     edge.width = E(g_ground_ff)$weight,  # エッジの太さ
     vertex.label = NA)  #ノードラベルを非表示

# 各ノードの次数を計算
node_degrees <- degree(g_ground_ff)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_ground_ff)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_ground_f*f_ranking.csv", row.names = FALSE)

# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_ground_f*f_ranking_with_taxonomy.csv", row.names = FALSE)


#####Module解析###############
# 1. Fast Greedy アルゴリズムを使用したモジュール検出
clusters_fast_greedy <- cluster_fast_greedy(g_ground_ff)
# 2. Louvain アルゴリズムを使用したモジュール検出
clusters_louvain <- cluster_louvain(g_ground_ff)
# 3. Infomap アルゴリズムを使用したモジュール検出
clusters_infomap <- cluster_infomap(g_ground_ff)
# 4. モジュール度（Modularity）の計算
modularity_fast_greedy <- modularity(clusters_fast_greedy)
modularity_louvain <- modularity(clusters_louvain)
modularity_infomap <- modularity(clusters_infomap)

# 結果を表示
print(modularity_fast_greedy)
print(modularity_louvain)
print(modularity_infomap)

plot(g_ground_ff, vertex.color = membership(clusters_fast_greedy), 
     layout = layout,
     vertex.size = 5, 
     edge.width = E(g_ground_ff)$weight,
     vertex.label = NA)

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_ground_ff, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_ground_ff, method = "NODF")
print(weighted_nodf)
# 隣接行列の重みの正規化
adjacency_matrix_normalized <- adjacency_ground_ff / max(adjacency_ground_ff)
weighted_nodf <- nested(adjacency_matrix_normalized, method = "NODF")
print(weighted_nodf)
# モジュール度の計算
modularity_value <- modularity(cluster_louvain(g_ground_ff))  # igraphを使ったモジュール度
print(modularity_value)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_ground_ff, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

#####帰無仮説との比較##############################################################################

library(igraph)
library(bipartite)

# 実際のネットワークのノード数とエッジ数
num_fungi <- vcount(g_ground_ff)  # ノード数
num_edges <- ecount(g_ground_ff)  # エッジ数

# 二部ネットワークのランダムグラフの指標を格納するためのリスト
random_connectance <- numeric(100)
random_nodf <- numeric(100)
random_modularity <- numeric(100)
random_h2 <- numeric(100)

set.seed(123)  # 再現性のためのシード設定

for (i in 1:100) {
  #i = 1
  # Generate random fungi-only network (Erdős–Rényi model)
  random_graph_ff <- erdos.renyi.game(num_fungi, num_edges, type = "gnm")
  
  # Calculate the metrics for the random graph
  adj_mat <- as_adjacency_matrix(random_graph_ff, sparse = FALSE)
  random_connectance[i] <- networklevel(adj_mat, index = "connectance")
  random_nodf[i] <- nested(adj_mat, method = "NODF")
  random_fungi_clusters <- cluster_fast_greedy(random_graph_ff)
  random_modularity[i] <- modularity(random_fungi_clusters)
  #random_h2[i] <- H2fun(adj_mat)[1]
}



# 結果の平均値を表示
cat("Connectanceの平均値: ", mean(random_connectance), "\n")
cat("NODFの平均値: ", mean(random_nodf), "\n")
cat("Modularityの平均値: ", mean(random_modularity), "\n")
cat("H2'の平均値: ", mean(random_h2), "\n")


# zスコアの計算
z_connectance <- (weighted_connectance - mean(random_connectance)) / sd(random_connectance)
z_nodf <- (weighted_nodf - mean(random_nodf)) / sd(random_nodf)
z_modularity <- (modularity_value - mean(random_modularity)) / sd(random_modularity)
z_h2 <- (H2_value - mean(random_h2)) / sd(random_h2)

# p値の計算
p_connectance <- sum(random_connectance >= weighted_connectance) / 100
p_nodf <- sum(random_nodf >= weighted_nodf) / 100
p_modularity <- sum(random_modularity >= modularity_value) / 100
p_h2 <- sum(random_h2 >= H2_value) / 100

# 結果の出力
cat("Connectance: zスコア =", z_connectance, ", p値 =", p_connectance, "\n")
cat("NODF: zスコア =", z_nodf, ", p値 =", p_nodf, "\n")
cat("Modularity: zスコア =", z_modularity, ", p値 =", p_modularity, "\n")
cat("H2': zスコア =", z_h2, ", p値 =", p_h2, "\n")


####canopy
# フィルタ後の真菌とバクテリアの列数を再定義
n_fungi_canopy <- ncol(asv_fungi_canopy)
n_bacteria_canopy <- ncol(asv_bacteria_canopy)

# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_canopy_table_filtered) %in% colnames(asv_fungi_canopy))
n_bacteria_filtered <- sum(colnames(combined_canopy_table_filtered) %in% colnames(asv_bacteria_canopy))

fungi_canopy_only_corr <- combined_canopy_table_filtered[1:n_fungi_filtered, 1:n_fungi_filtered]
fungi_canopy_only_corr <- fungi_canopy_only_corr[1:44, ]

# 各列の標準偏差を計算
sd_values <- apply(fungi_canopy_only_corr, 2, sd)
# 標準偏差がゼロの列を確認
zero_sd_cols <- which(sd_values == 0)
print(zero_sd_cols)  # 標準偏差がゼロの列番号を確認
# 標準偏差がゼロでない列を残す
fungi_canopy_filtered <- fungi_canopy_only_corr[, sd_values > 0]
# Spearman相関行列を計算
correlation_fungi_canopy_matrix <- cor(fungi_canopy_filtered, method = "spearman")
# 対角成分（自己相関）は 0 にする
diag(correlation_fungi_canopy_matrix) <- 0

# 閾値を設定して相関係数をフィルタリング（0.4以上の相関のみ残す）
adjacency_canopy_ff <- ifelse(correlation_fungi_canopy_matrix >= 0.6, correlation_fungi_canopy_matrix, 0)

# ASVに基づく重み付きグラフを作成
g_canopy_ff <- graph_from_adjacency_matrix(adjacency_canopy_ff, mode = "undirected", weighted = TRUE, diag = FALSE)
# エッジのないノードを削除
g_canopy_ff <- delete_vertices(g_canopy_ff, degree(g_canopy_ff) == 0)
V(g_canopy_ff)$name
# 削除後に残ったノード（ASV）名を確認
remaining_asvs <- V(g_canopy_ff)$name
print(remaining_asvs)

# 'remaining_asvs' に基づいて taxonomy_fungi_filtered から対応するタクソノミー情報を抽出
remaining_taxonomy_fungi <- taxonomy_fungi_filtered[rownames(taxonomy_fungi_filtered) %in% remaining_asvs, ]
# 'Class' 情報を抽出
taxonomy_fungi_canopy_class <- remaining_taxonomy_fungi[, "Class"]

# ユニークなクラスごとに色を設定（暖色系のパレット "Set1" を使用）
unique_classes <- unique(taxonomy_fungi_canopy_class)
palette <- brewer.pal(min(length(unique_classes), 9), "Set1")  # "Set1" の色を取得（最大9色まで）
if (length(unique_classes) > 9) {
  palette <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_classes))  # 9色以上の場合に拡張
}
class_colors <- setNames(palette, unique_classes)

# クラスに基づいてノードに色を割り当てる
node_colors <- class_colors[taxonomy_fungi_canopy_class]
V(g_canopy_ff)$color <- node_colors

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_ff)  # Fruchterman-Reingold レイアウト

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_ff)

# ノードのサイズを次数に比例させる
V(g_canopy_ff)$size <- log(node_degrees + 1) * 5  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# ノードの透明度を高め、サイズを小さくしてネットワーク図を描画
plot(g_canopy_ff, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(V(g_canopy_ff)$color, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_ff)$size,  # ノードのサイズを次数に比例させる
     edge.width = E(g_canopy_ff)$weight*5,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_ff)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_ff)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_canopy_f*f_ranking.csv", row.names = FALSE)

# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_canopy_f*f_ranking_with_taxonomy.csv", row.names = FALSE)

#####Module解析###############
# 1. Fast Greedy アルゴリズムを使用したモジュール検出
clusters_fast_greedy <- cluster_fast_greedy(g_canopy_ff)
# 2. Louvain アルゴリズムを使用したモジュール検出
clusters_louvain <- cluster_louvain(g_canopy_ff)
# 3. Infomap アルゴリズムを使用したモジュール検出
clusters_infomap <- cluster_infomap(g_canopy_ff)
# 4. モジュール度（Modularity）の計算
modularity_fast_greedy <- modularity(clusters_fast_greedy)
modularity_louvain <- modularity(clusters_louvain)
modularity_infomap <- modularity(clusters_infomap)

# 結果を表示
print(modularity_fast_greedy)
print(modularity_louvain)
print(modularity_infomap)

plot(g_canopy_ff, vertex.color = membership(clusters_fast_greedy), 
     layout = layout,
     vertex.size = 5, 
     edge.width = E(g_canopy_ff)$weight,
     vertex.label = NA)



#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_ff, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_ff, method = "NODF")
print(weighted_nodf)
# 隣接行列の重みの正規化
adjacency_matrix_normalized <- adjacency_canopy_ff / max(adjacency_canopy_ff)
weighted_nodf <- nested(adjacency_matrix_normalized, method = "NODF")
print(weighted_nodf)
# モジュール度の計算
module_result <- computeModules(adjacency_canopy_ff)
modularity_value <- module_result@likelihood
print(modularity_value)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_ff, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

### bacteria 同士の相関行列を抽出.#############################################################################################################################################
####ground
# フィルタ後の真菌とバクテリアの列数を再定義
n_bacteria_ground <- ncol(asv_fungi_ground)
n_bacteria_ground <- ncol(asv_bacteria_ground)

# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_ground_table_filtered) %in% colnames(asv_fungi_ground))
n_bacteria_filtered <- sum(colnames(combined_ground_table_filtered) %in% colnames(asv_bacteria_ground))
bacteria_ground_only_corr <- combined_ground_table_filtered[, (n_fungi_filtered + 1):(n_fungi_filtered + n_bacteria_filtered)]

# 各列の標準偏差を計算
sd_values <- apply(bacteria_ground_only_corr, 2, sd)
# 標準偏差がゼロの列を確認
zero_sd_cols <- which(sd_values == 0)
print(zero_sd_cols)  # 標準偏差がゼロの列番号を確認
# 標準偏差がゼロでない列を残す
bacteria_ground_filtered <- bacteria_ground_only_corr[, sd_values > 0]
# Spearman相関行列を計算
correlation_bacteria_ground_matrix <- cor(bacteria_ground_filtered, method = "spearman")
# 対角成分（自己相関）は 0 にする
diag(correlation_bacteria_ground_matrix) <- 0

# 閾値を設定して相関係数をフィルタリング（0.4以上の相関のみ残す）
adjacency_ground_bb <- ifelse(correlation_bacteria_ground_matrix >= 0.5, correlation_bacteria_ground_matrix*5, 0)

# ASVに基づく重み付きグラフを作成
g_ground_bb <- graph_from_adjacency_matrix(adjacency_ground_bb, mode = "undirected", weighted = TRUE, diag = FALSE)
# エッジのないノードを削除
g_ground_bb <- delete_vertices(g_ground_bb, degree(g_ground_bb) == 0)
V(g_ground_bb)$name
# 削除後に残ったノード（ASV）名を確認
remaining_asvs <- V(g_ground_bb)$name
print(remaining_asvs)

# 'remaining_asvs' に基づいて taxonomy_fungi_filtered から対応するタクソノミー情報を抽出
remaining_taxonomy_bacteria <- taxonomy_bacteria_filtered[rownames(taxonomy_bacteria_filtered) %in% remaining_asvs, ]
# 'Class' 情報を抽出
taxonomy_bacteria_ground_class <- remaining_taxonomy_bacteria[, "Class"]

# ユニークなクラスごとに色を設定（暖色系のパレット "Set1" を使用）
unique_classes <- unique(taxonomy_bacteria_ground_class)
palette <- brewer.pal(min(length(unique_classes), 9), "Set1")  # "Set1" の色を取得（最大9色まで）
if (length(unique_classes) > 9) {
  palette <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_classes))  # 9色以上の場合に拡張
}
class_colors <- setNames(palette, unique_classes)

# クラスに基づいてノードに色を割り当てる
node_colors <- class_colors[taxonomy_bacteria_ground_class]
V(g_ground_bb)$color <- node_colors

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_ground_bb)

# 各ノードの次数を取得
node_degrees <- degree(g_ground_bb)

# ノードのサイズを次数に比例させる
V(g_ground_bb)$size <- log(node_degrees + 1) * 5  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# ノードの透明度を高め、サイズを小さくしてネットワーク図を描画
plot(g_ground_bb, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(V(g_ground_bb)$color, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_ground_bb)$size,  # ノードのサイズを次数に比例させる
     edge.width = E(g_ground_bb)$weight,  # エッジの太さ
     vertex.label = NA)  #ノードラベルを非表示

# 各ノードの次数を計算
node_degrees <- degree(g_ground_bb)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_ground_bb)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_ground_b*b_ranking_r=0.5.csv", row.names = FALSE)

# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_ground_b*b_ranking_with_taxonomy_0.6.csv", row.names = FALSE)


#####Module解析###############
# 1. Fast Greedy アルゴリズムを使用したモジュール検出
clusters_fast_greedy <- cluster_fast_greedy(g_ground_bb)
# 2. Louvain アルゴリズムを使用したモジュール検出
clusters_louvain <- cluster_louvain(g_ground_bb)
# 3. Infomap アルゴリズムを使用したモジュール検出
clusters_infomap <- cluster_infomap(g_ground_bb)
# 4. モジュール度（Modularity）の計算
modularity_fast_greedy <- modularity(clusters_fast_greedy)
modularity_louvain <- modularity(clusters_louvain)
modularity_infomap <- modularity(clusters_infomap)

# 結果を表示
print(modularity_fast_greedy)
print(modularity_louvain)
print(modularity_infomap)

plot(g_ground_bb, vertex.color = membership(clusters_fast_greedy), 
     layout = layout,
     vertex.size = 5, 
     edge.width = E(g_ground_bb)$weight,
     vertex.label = NA)

#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_ground_bb, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_ground_bb, method = "NODF")
print(weighted_nodf)
# 隣接行列の重みの正規化
adjacency_matrix_normalized <- adjacency_ground_bb / max(adjacency_ground_bb)
weighted_nodf <- nested(adjacency_matrix_normalized, method = "NODF")
print(weighted_nodf)
# モジュール度の計算
modularity_value <- modularity(cluster_louvain(g_ground_bb))  # igraphを使ったモジュール度
print(modularity_value)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_ground_bb, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)

####canopy
# フィルタ後の真菌とバクテリアの列数を再定義
n_fungi_canopy <- ncol(asv_fungi_canopy)
n_bacteria_canopy <- ncol(asv_bacteria_canopy)

# フィルタ後のテーブルで真菌とバクテリアの列数を再確認
n_fungi_filtered <- sum(colnames(combined_canopy_table_filtered) %in% colnames(asv_fungi_canopy))
n_bacteria_filtered <- sum(colnames(combined_canopy_table_filtered) %in% colnames(asv_bacteria_canopy))

bacteria_canopy_only_corr <- combined_canopy_table_filtered[, (n_fungi_filtered + 1):(n_fungi_filtered + n_bacteria_filtered)]

# 各列の標準偏差を計算
sd_values <- apply(bacteria_canopy_only_corr, 2, sd)
# 標準偏差がゼロの列を確認
zero_sd_cols <- which(sd_values == 0)
print(zero_sd_cols)  # 標準偏差がゼロの列番号を確認
# 標準偏差がゼロでない列を残す
bacteria_canopy_filtered <- bacteria_canopy_only_corr[, sd_values > 0]
# Spearman相関行列を計算
correlation_bacteria_canopy_matrix <- cor(bacteria_canopy_filtered, method = "spearman")
# 対角成分（自己相関）は 0 にする
diag(correlation_bacteria_canopy_matrix) <- 0

# 閾値を設定して相関係数をフィルタリング（0.4以上の相関のみ残す）
adjacency_canopy_bb <- ifelse(correlation_bacteria_canopy_matrix >= 0.5, correlation_bacteria_canopy_matrix, 0)

# ASVに基づく重み付きグラフを作成
g_canopy_bb <- graph_from_adjacency_matrix(adjacency_canopy_bb, mode = "undirected", weighted = TRUE, diag = FALSE)
# エッジのないノードを削除
g_canopy_bb <- delete_vertices(g_canopy_bb, degree(g_canopy_bb) == 0)
V(g_canopy_bb)$name
# 削除後に残ったノード（ASV）名を確認
remaining_asvs <- V(g_canopy_bb)$name
print(remaining_asvs)

# 'remaining_asvs' に基づいて taxonomy_fungi_filtered から対応するタクソノミー情報を抽出
remaining_taxonomy_bacteria <- taxonomy_bacteria_filtered[rownames(taxonomy_bacteria_filtered) %in% remaining_asvs, ]
# 'Class' 情報を抽出
taxonomy_bacteria_canopy_class <- remaining_taxonomy_bacteria[, "Class"]

# ユニークなクラスごとに色を設定（暖色系のパレット "Set1" を使用）
unique_classes <- unique(taxonomy_bacteria_canopy_class)
palette <- brewer.pal(min(length(unique_classes), 9), "Set1")  # "Set1" の色を取得（最大9色まで）
if (length(unique_classes) > 9) {
  palette <- colorRampPalette(brewer.pal(9, "Set1"))(length(unique_classes))  # 9色以上の場合に拡張
}
class_colors <- setNames(palette, unique_classes)

# クラスに基づいてノードに色を割り当てる
node_colors <- class_colors[taxonomy_bacteria_canopy_class]
V(g_canopy_bb)$color <- node_colors

# Fruchterman-Reingold レイアウトを使用してノードを重ならないように配置
layout <- layout_with_fr(g_canopy_bb)  # Fruchterman-Reingold レイアウト

# 各ノードの次数を取得
node_degrees <- degree(g_canopy_bb)

# ノードのサイズを次数に比例させる
V(g_canopy_bb)$size <- log(node_degrees + 1) * 5  # 対数スケーリングを適用し、倍率を調整

set.seed(10)

# ノードの透明度を高め、サイズを小さくしてネットワーク図を描画
plot(g_canopy_bb, 
     layout = layout,  # レイアウトを指定
     vertex.color = adjustcolor(V(g_canopy_bb)$color, alpha.f = 0.7),  # ノードの色と透明度
     vertex.size = V(g_canopy_bb)$size,  # ノードのサイズを次数に比例させる
     edge.width = E(g_canopy_bb)$weight*5,  # エッジの太さ
     vertex.label = NA)  # ノードラベルを非表示

# 各ノードの次数を計算
node_degrees <- degree(g_canopy_bb)

# ノード名と次数をデータフレームにまとめる
node_degree_df <- data.frame(
  Node = V(g_canopy_bb)$name,  # ノード名
  Degree = node_degrees  # 次数
)

# 次数で降順に並べ替える
node_degree_df <- node_degree_df[order(-node_degree_df$Degree), ]

# 上位のノードを確認する
print(head(node_degree_df))  # 上位ノードを確認（必要に応じてhead()の引数で個数を調整）

# 必要に応じてデータフレームを保存
write.csv(node_degree_df, "node_degree_canopy_b*b_ranking_0.5.csv", row.names = FALSE)

# node_degree_dfとtaxonomy_combined_with_asvをASV名で結合
node_degree_with_taxonomy <- node_degree_df %>%
  left_join(taxonomy_combined_with_asv, by = c("Node" = "ASV"))  # ASV名で結合
# タクソノミー情報が追加されたデータフレームを確認
print(head(node_degree_with_taxonomy))
# 必要に応じてCSVファイルとして保存
write.csv(node_degree_with_taxonomy, "node_degree_canopy_b*b_ranking_with_taxonomy_0.5.csv", row.names = FALSE)

#####Module解析###############
# 1. Fast Greedy アルゴリズムを使用したモジュール検出
clusters_fast_greedy <- cluster_fast_greedy(g_canopy_bb)
# 2. Louvain アルゴリズムを使用したモジュール検出
clusters_louvain <- cluster_louvain(g_canopy_bb)
# 3. Infomap アルゴリズムを使用したモジュール検出
clusters_infomap <- cluster_infomap(g_canopy_bb)
# 4. モジュール度（Modularity）の計算
modularity_fast_greedy <- modularity(clusters_fast_greedy)
modularity_louvain <- modularity(clusters_louvain)
modularity_infomap <- modularity(clusters_infomap)

# 結果を表示
print(modularity_fast_greedy)
print(modularity_louvain)
print(modularity_infomap)

plot(g_canopy_bb, vertex.color = membership(clusters_fast_greedy), 
     layout = layout,
     vertex.size = 5, 
     edge.width = E(g_canopy_bb)$weight,
     vertex.label = NA)



#####重み結合度等の計算！"bipartite"を使うので、igraphを使い終わってから立ち上げる！############
# weighted connectance の計算
# igraphオブジェクトから隣接行列を抽出
# 重み付き結合度の計算
weighted_connectance <- networklevel(adjacency_canopy_ff, index = "connectance", weighted = TRUE)
print(weighted_connectance)
# 入れ子度（NODF）の計算
weighted_nodf <- nested(adjacency_canopy_ff, method = "NODF")
print(weighted_nodf)
# 隣接行列の重みの正規化
adjacency_matrix_normalized <- adjacency_canopy_ff / max(adjacency_canopy_ff)
weighted_nodf <- nested(adjacency_matrix_normalized, method = "NODF")
print(weighted_nodf)
# モジュール度の計算
module_result <- computeModules(adjacency_canopy_ff)
modularity_value <- module_result@likelihood
print(modularity_value)
# 相互作用特殊化度 (H2') の計算
H2_value <- H2fun(adjacency_canopy_ff, H2_integer = FALSE)  # H2_integer は整数行列かどうかの指定
print(H2_value)
